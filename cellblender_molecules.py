# ##### BEGIN GPL LICENSE BLOCK #####
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# ##### END GPL LICENSE BLOCK #####

# <pep8 compliant>

"""
This file contains the classes for CellBlender's Molecules.

"""

# blender imports
import bpy
from bpy.props import BoolProperty, CollectionProperty, EnumProperty, \
                      FloatProperty, FloatVectorProperty, IntProperty, \
                      IntVectorProperty, PointerProperty, StringProperty
from bpy.app.handlers import persistent
import math
import mathutils

# python imports
import re
import os
import random

import cellblender
# from . import cellblender_parameters
from . import parameter_system
from . import cellblender_mol_viz
from . import cellblender_utils


# We use per module class registration/unregistration
def register():
    bpy.utils.register_module(__name__)


def unregister():
    bpy.utils.unregister_module(__name__)


def set_molecule_glyph ( context, glyph_name ):

    mcell = context.scene.mcell
    meshes = bpy.data.meshes
    mcell.molecule_glyphs.status = ""
    select_objs = context.selected_objects
    if (len(select_objs) != 1):
        mcell.molecule_glyphs.status = "Select One Molecule"
        return
    if (select_objs[0].type != 'MESH'):
        mcell.molecule_glyphs.status = "Selected Object Not a Molecule"
        return

    mol_obj = select_objs[0]
    mol_shape_name = mol_obj.name

    # There may be objects in the scene with the same name as the glyphs in
    # the glyph library, so we need to deal with this possibility
    new_glyph_name = glyph_name
    if glyph_name in meshes:
        # pattern: glyph name, period, numbers. (example match: "Cube.001")
        pattern = re.compile(r'%s(\.\d+)' % glyph_name)
        competing_names = [m.name for m in meshes if pattern.match(m.name)]
        # example: given this: ["Cube.001", "Cube.3"], make this: [1, 3]
        trailing_nums = [int(n.split('.')[1]) for n in competing_names]
        # remove dups & sort... better way than list->set->list?
        trailing_nums = list(set(trailing_nums))
        trailing_nums.sort()
        i = 0
        gap = False
        for i in range(0, len(trailing_nums)):
            if trailing_nums[i] != i+1:
                gap = True
                break
        if not gap and trailing_nums:
            i+=1
        new_glyph_name = "%s.%03d" % (glyph_name, i + 1)

    if (bpy.app.version[0] > 2) or ( (bpy.app.version[0]==2) and (bpy.app.version[1] > 71) ):
      bpy.ops.wm.link(
          directory=mcell.molecule_glyphs.glyph_lib,
          files=[{"name": glyph_name}], link=False, autoselect=False)
    else:
      bpy.ops.wm.link_append(
          directory=mcell.molecule_glyphs.glyph_lib,
          files=[{"name": glyph_name}], link=False, autoselect=False)

    mol_mat = mol_obj.material_slots[0].material
    new_mol_mesh = meshes[new_glyph_name]
    mol_obj.data = new_mol_mesh
    mol_obj.hide_select = True
    meshes.remove(meshes[mol_shape_name])

    new_mol_mesh.name = mol_shape_name
    new_mol_mesh.materials.append(mol_mat)


class MCellMoleculeGlyphsPropertyGroup(bpy.types.PropertyGroup):
    glyph_lib = os.path.join(
        os.path.dirname(__file__), "glyph_library.blend/Mesh/")
    glyph_enum = [
        ('Cone', "Cone", ""),
        ('Cube', "Cube", ""),
        ('Cylinder', "Cylinder", ""),
        ('Icosahedron', "Icosahedron", ""),
        ('Octahedron', "Octahedron", ""),
        ('Receptor', "Receptor", ""),
        ('Sphere_1', "Sphere_1", ""),
        ('Sphere_2', "Sphere_2", ""),
        ('Torus', "Torus", "")]
    glyph = EnumProperty(items=glyph_enum, name="Molecule Shapes")
    show_glyph = BoolProperty(name="Show Glyphs",description="Show Glyphs ... can cause slowness!!",default=True)
    status = StringProperty(name="Status")

    def remove_properties ( self, context ):
        print ( "Removing all Molecule Glyph Properties... no collections to remove." )





#### Start of Molecule Shape Code - This might go best in another file ####

class point:
  x=0;
  y=0;
  z=0;

  def __init__ ( self, x, y, z ):
    self.x = x;
    self.y = y;
    self.z = z;

  def toList ( self ):
    return ( [ self.x, self.y, self.z ] );

  def toString ( self ):
    return ( "(" + str(self.x) + "," + str(self.y) + "," + str(self.z) + ")" );


class face:
  verts = [];

  def __init__ ( self, v1, v2, v3 ):
    self.verts = [];
    self.verts.append ( v1 );
    self.verts.append ( v2 );
    self.verts.append ( v3 );

  def toString( self ):
    return ( "[" + str(verts[0]) + "," + str(verts[1]) + "," + str(verts[2]) + "]" );


class plf_object:

  # An object that can hold points and faces (the "L" in PLF stood for Lines which are not needed here)

  points = []
  faces = []

  def __init__ ( self ):
    self.points = []
    self.faces = []



class Tetrahedron (plf_object):

  def __init__ ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    # Create a tetrahedron of the requested size

    size_scale = 0.05 * 0.1

    self.points = [];
    self.faces = [];

    z = 1 / math.sqrt(2)
    sqr3 = math.sqrt(3)
    sqr3i = 1 / sqr3
    sqr23 = math.sqrt(2.0/3.0)

    self.points = self.points + [ point (  0*size_x*size_scale, (sqr3-sqr3i)*size_y*size_scale, -sqr23*size_z*size_scale ) ]
    self.points = self.points + [ point ( -1*size_x*size_scale,       -sqr3i*size_y*size_scale, -sqr23*size_z*size_scale ) ]
    self.points = self.points + [ point (  1*size_x*size_scale,       -sqr3i*size_y*size_scale, -sqr23*size_z*size_scale ) ]
    self.points = self.points + [ point (  0*size_x*size_scale,            0*size_y*size_scale,  sqr23*size_z*size_scale ) ]

    face_list = [ [ 0, 2, 1 ], [ 0, 3, 2 ], [ 0, 1, 3 ], [ 1, 2, 3 ] ]

    for f in face_list:
      self.faces.append ( face ( f[0], f[1], f[2] ) )


class Pyramid (plf_object):

  def __init__ ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    # Create a pyramid of the requested size

    size_scale = 0.05 * 0.1

    self.points = [];
    self.faces = [];

    self.points = self.points + [ point (  size_x*size_scale,  size_y*size_scale, -size_z*size_scale ) ]
    self.points = self.points + [ point (  size_x*size_scale, -size_y*size_scale, -size_z*size_scale ) ]
    self.points = self.points + [ point ( -size_x*size_scale, -size_y*size_scale, -size_z*size_scale ) ]
    self.points = self.points + [ point ( -size_x*size_scale,  size_y*size_scale, -size_z*size_scale ) ]
    self.points = self.points + [ point (     0.0*size_scale,     0.0*size_scale,  size_z*size_scale ) ]

    face_list = [ [ 1, 2, 3 ], [ 0, 1, 3 ], [ 0, 4, 1 ],
                  [ 1, 4, 2 ], [ 2, 4, 3 ], [ 3, 4, 0 ] ]

    for f in face_list:
      self.faces.append ( face ( f[0], f[1], f[2] ) )


class BasicBox (plf_object):

  def __init__ ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    # Create a box of the requested size

    size_scale = 0.05 * 0.1

    self.points = [];
    self.faces = [];

    self.points = self.points + [ point (  size_x*size_scale,  size_y*size_scale, -size_z*size_scale ) ]
    self.points = self.points + [ point (  size_x*size_scale, -size_y*size_scale, -size_z*size_scale ) ]
    self.points = self.points + [ point ( -size_x*size_scale, -size_y*size_scale, -size_z*size_scale ) ]
    self.points = self.points + [ point ( -size_x*size_scale,  size_y*size_scale, -size_z*size_scale ) ]
    self.points = self.points + [ point (  size_x*size_scale,  size_y*size_scale,  size_z*size_scale ) ]
    self.points = self.points + [ point (  size_x*size_scale, -size_y*size_scale,  size_z*size_scale ) ]
    self.points = self.points + [ point ( -size_x*size_scale, -size_y*size_scale,  size_z*size_scale ) ]
    self.points = self.points + [ point ( -size_x*size_scale,  size_y*size_scale,  size_z*size_scale ) ]

    face_list = [ [ 1, 2, 3 ], [ 7, 6, 5 ], [ 4, 5, 1 ], [ 5, 6, 2 ],
                  [ 2, 6, 7 ], [ 0, 3, 7 ], [ 0, 1, 3 ], [ 4, 7, 5 ],
                  [ 0, 4, 1 ], [ 1, 5, 2 ], [ 3, 2, 7 ], [ 4, 0, 7 ] ]

    for f in face_list:
      self.faces.append ( face ( f[0], f[1], f[2] ) )



class CellBlender_Octahedron (plf_object):

  def __init__ ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    # Create an object of the requested size
    size_scale = 1

    self.points = [];
    self.faces = [];

    pts = [
      [0.005,0.005,0],[0.005,-0.005,0],[-0.005,-0.005,0],[-0.005,0.005,0],[0,0,0.005],[0,0,-0.005] ]

    fcs = [
      [0,4,1],[0,1,5],[0,3,4],[2,4,3],[1,4,2],[1,2,5],[2,3,5],[0,5,3] ]

    self.points = [];
    self.faces = [];
    for p in pts:
      self.points.append ( point ( size_scale*size_x*p[0], size_scale*size_y*p[1], size_scale*size_z*p[2] ) )
    for f in fcs:
      self.faces.append ( face ( f[0], f[1], f[2] ) )


class CellBlender_Cube (plf_object):

  def __init__ ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    # Create an object of the requested size
    size_scale = 1

    self.points = [];
    self.faces = [];

    pts = [
      [0.005,0.005,-0.005],[0.005,-0.005,-0.005],[-0.005,-0.005,-0.005],[-0.005,0.005,-0.005],[0.005,0.005,0.005],
      [0.005,-0.005,0.005],[-0.005,-0.005,0.005],[-0.005,0.005,0.005] ]

    fcs = [
      [1,2,3],[7,6,5],[4,5,1],[5,6,2],[2,6,7],[0,3,7],[0,1,3],[4,7,5],[0,4,1],[1,5,2],[3,2,7], [4,0,7] ]

    self.points = [];
    self.faces = [];
    for p in pts:
      self.points.append ( point ( size_scale*size_x*p[0], size_scale*size_y*p[1], size_scale*size_z*p[2] ) )
    for f in fcs:
      self.faces.append ( face ( f[0], f[1], f[2] ) )


class CellBlender_Icosahedron (plf_object):

  def __init__ ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    # Create an object of the requested size
    size_scale = 1

    self.points = [];
    self.faces = [];

    pts = [
      [0,0,-0.005],[0.003618,-0.002629,-0.002236],[-0.001382,-0.004253,-0.002236],[-0.004472,0,-0.002236],[-0.001382,0.004253,-0.002236],
      [0.003618,0.002629,-0.002236],[0.001382,-0.004253,0.002236],[-0.003618,-0.002629,0.002236],[-0.003618,0.002629,0.002236],
      [0.001382,0.004253,0.002236],[0.004472,0,0.002236],[0,0,0.005] ]

    fcs = [
      [2,0,1],[1,0,5],[3,0,2],[4,0,3],[5,0,4],[1,5,10],[2,1,6],[3,2,7],[4,3,8],[5,4,9],[6,1,10],
      [7,2,6],[8,3,7],[9,4,8],[10,5,9],[6,10,11],[7,6,11],[8,7,11],[9,8,11],[10,9,11] ]

    self.points = [];
    self.faces = [];
    for p in pts:
      self.points.append ( point ( size_scale*size_x*p[0], size_scale*size_y*p[1], size_scale*size_z*p[2] ) )
    for f in fcs:
      self.faces.append ( face ( f[0], f[1], f[2] ) )


class CellBlender_Cone (plf_object):

  def __init__ ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    # Create an object of the requested size
    size_scale = 1

    self.points = [];
    self.faces = [];

    pts = [
      [0,0.005,-0.005],[0.001913,0.004619,-0.005],[0.003536,0.003536,-0.005],[0.004619,0.001913,-0.005],[0.005,0,-0.005],
      [0.004619,-0.001913,-0.005],[0.003536,-0.003536,-0.005],[0.001913,-0.004619,-0.005],[0,-0.005,-0.005],
      [-0.001913,-0.004619,-0.005],[-0.003536,-0.003536,-0.005],[-0.004619,-0.001913,-0.005],[-0.005,0,-0.005],
      [-0.004619,0.001913,-0.005],[-0.003536,0.003536,-0.005],[-0.001913,0.004619,-0.005],[0,0,0.005],[0,0,-0.005] ]

    fcs = [
      [1,0,16],[16,2,1],[16,3,2],[16,4,3],[16,5,4],[16,6,5],[16,7,6],[16,8,7],[16,9,8],[16,10,9],[16,11,10],
      [16,12,11],[16,13,12],[16,14,13],[16,15,14],[16,0,15],[17,0,1],[17,1,2],[17,2,3],[17,3,4],[17,4,5],[17,5,6],
      [17,6,7],[17,7,8],[17,8,9],[17,9,10],[17,10,11],[17,11,12],[17,12,13],[17,13,14],[17,14,15],[15,0,17] ]

    self.points = [];
    self.faces = [];
    for p in pts:
      self.points.append ( point ( size_scale*size_x*p[0], size_scale*size_y*p[1], size_scale*size_z*p[2] ) )
    for f in fcs:
      self.faces.append ( face ( f[0], f[1], f[2] ) )


class CellBlender_Cylinder (plf_object):

  def __init__ ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    # Create an object of the requested size
    size_scale = 1

    self.points = [];
    self.faces = [];

    pts = [
      [0,0.005,-0.005],[0.001913,0.004619,-0.005],[0.003536,0.003536,-0.005],[0.004619,0.001913,-0.005],[0.005,0,-0.005],
      [0.004619,-0.001913,-0.005],[0.003536,-0.003536,-0.005],[0.001913,-0.004619,-0.005],[0,-0.005,-0.005],
      [-0.001913,-0.004619,-0.005],[-0.003536,-0.003536,-0.005],[-0.004619,-0.001913,-0.005],[-0.005,0,-0.005],
      [-0.004619,0.001913,-0.005],[-0.003536,0.003536,-0.005],[-0.001913,0.004619,-0.005],[0,0.005,0.005],
      [0.001913,0.004619,0.005],[0.003536,0.003536,0.005],[0.004619,0.001913,0.005],[0.005,0,0.005],
      [0.004619,-0.001913,0.005],[0.003536,-0.003536,0.005],[0.001913,-0.004619,0.005],[0,-0.005,0.005],
      [-0.001913,-0.004619,0.005],[-0.003536,-0.003536,0.005],[-0.004619,-0.001913,0.005],[-0.005,0,0.005],
      [-0.004619,0.001913,0.005],[-0.003536,0.003536,0.005],[-0.001913,0.004619,0.005],[0,0,-0.005],[0,0,0.005] ]

    fcs = [
      [32,0,1],[33,17,16],[32,1,2],[33,18,17],[32,2,3],[33,19,18],[32,3,4],[33,20,19],[32,4,5],[33,21,20],[32,5,6],
      [33,22,21],[32,6,7],[33,23,22],[32,7,8],[33,24,23],[32,8,9],[33,25,24],[32,9,10],[33,26,25],[32,10,11],
      [33,27,26],[32,11,12],[33,28,27],[32,12,13],[33,29,28],[32,13,14],[33,30,29],[32,14,15],[33,31,30],[15,0,32],
      [33,16,31],[16,17,1],[17,18,2],[18,19,3],[19,20,4],[20,21,5],[21,22,6],[22,23,7],[23,24,8],[24,25,9],
      [25,26,10],[26,27,11],[27,28,12],[28,29,13],[29,30,14],[30,31,15],[0,15,31],[0,16,1],[1,17,2],[2,18,3],
      [3,19,4],[4,20,5],[5,21,6],[6,22,7],[7,23,8],[8,24,9],[9,25,10],[10,26,11],[11,27,12],[12,28,13],[13,29,14],
      [14,30,15],[16,0,31] ]

    self.points = [];
    self.faces = [];
    for p in pts:
      self.points.append ( point ( size_scale*size_x*p[0], size_scale*size_y*p[1], size_scale*size_z*p[2] ) )
    for f in fcs:
      self.faces.append ( face ( f[0], f[1], f[2] ) )


class CellBlender_Torus (plf_object):

  def __init__ ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    # Create an object of the requested size
    size_scale = 1

    self.points = [];
    self.faces = [];

    pts = [
      [0.005,0,0],[0.004905,0,0.0004784],[0.004634,0,0.0008839],[0.004228,0,0.001155],[0.00375,0,0.00125],[0.003272,0,0.001155],
      [0.002866,0,0.0008839],[0.002595,0,0.0004784],[0.0025,0,0],[0.002595,0,-0.0004784],[0.002866,0,-0.0008839],
      [0.003272,0,-0.001155],[0.00375,0,-0.00125],[0.004228,0,-0.001155],[0.004634,0,-0.0008839],[0.004905,0,-0.0004784],
      [0.004619,0.001913,0],[0.004531,0.001877,0.0004784],[0.004281,0.001773,0.0008839],[0.003906,0.001618,0.001155],
      [0.003465,0.001435,0.00125],[0.003023,0.001252,0.001155],[0.002648,0.001097,0.0008839],[0.002398,0.0009931,0.0004784],
      [0.00231,0.0009567,0],[0.002398,0.0009931,-0.0004784],[0.002648,0.001097,-0.0008839],[0.003023,0.001252,-0.001155],
      [0.003465,0.001435,-0.00125],[0.003906,0.001618,-0.001155],[0.004281,0.001773,-0.0008839],[0.004531,0.001877,-0.0004784],
      [0.003536,0.003536,0],[0.003468,0.003468,0.0004784],[0.003277,0.003277,0.0008839],[0.00299,0.00299,0.001155],
      [0.002652,0.002652,0.00125],[0.002313,0.002313,0.001155],[0.002027,0.002027,0.0008839],[0.001835,0.001835,0.0004784],
      [0.001768,0.001768,0],[0.001835,0.001835,-0.0004784],[0.002027,0.002027,-0.0008839],[0.002313,0.002313,-0.001155],
      [0.002652,0.002652,-0.00125],[0.00299,0.00299,-0.001155],[0.003277,0.003277,-0.0008839],[0.003468,0.003468,-0.0004784],
      [0.001913,0.004619,0],[0.001877,0.004531,0.0004784],[0.001773,0.004281,0.0008839],[0.001618,0.003906,0.001155],
      [0.001435,0.003465,0.00125],[0.001252,0.003023,0.001155],[0.001097,0.002648,0.0008839],[0.0009931,0.002398,0.0004784],
      [0.0009567,0.00231,0],[0.0009931,0.002398,-0.0004784],[0.001097,0.002648,-0.0008839],[0.001252,0.003023,-0.001155],
      [0.001435,0.003465,-0.00125],[0.001618,0.003906,-0.001155],[0.001773,0.004281,-0.0008839],[0.001877,0.004531,-0.0004784],
      [0,0.005,0],[0,0.004905,0.0004784],[0,0.004634,0.0008839],[0,0.004228,0.001155],
      [0,0.00375,0.00125],[0,0.003272,0.001155],[0,0.002866,0.0008839],[0,0.002595,0.0004784],
      [0,0.0025,0],[0,0.002595,-0.0004784],[0,0.002866,-0.0008839],[0,0.003272,-0.001155],
      [0,0.00375,-0.00125],[0,0.004228,-0.001155],[0,0.004634,-0.0008839],[0,0.004905,-0.0004784],
      [-0.001913,0.004619,0],[-0.001877,0.004531,0.0004784],[-0.001773,0.004281,0.0008839],[-0.001618,0.003906,0.001155],
      [-0.001435,0.003465,0.00125],[-0.001252,0.003023,0.001155],[-0.001097,0.002648,0.0008839],[-0.0009931,0.002398,0.0004784],
      [-0.0009567,0.00231,0],[-0.0009931,0.002398,-0.0004784],[-0.001097,0.002648,-0.0008839],[-0.001252,0.003023,-0.001155],
      [-0.001435,0.003465,-0.00125],[-0.001618,0.003906,-0.001155],[-0.001773,0.004281,-0.0008839],[-0.001877,0.004531,-0.0004784],
      [-0.003536,0.003536,0],[-0.003468,0.003468,0.0004784],[-0.003277,0.003277,0.0008839],[-0.00299,0.00299,0.001155],
      [-0.002652,0.002652,0.00125],[-0.002313,0.002313,0.001155],[-0.002027,0.002027,0.0008839],[-0.001835,0.001835,0.0004784],
      [-0.001768,0.001768,0],[-0.001835,0.001835,-0.0004784],[-0.002027,0.002027,-0.0008839],[-0.002313,0.002313,-0.001155],
      [-0.002652,0.002652,-0.00125],[-0.00299,0.00299,-0.001155],[-0.003277,0.003277,-0.0008839],[-0.003468,0.003468,-0.0004784],
      [-0.004619,0.001913,0],[-0.004531,0.001877,0.0004784],[-0.004281,0.001773,0.0008839],[-0.003906,0.001618,0.001155],
      [-0.003465,0.001435,0.00125],[-0.003023,0.001252,0.001155],[-0.002648,0.001097,0.0008839],[-0.002398,0.0009931,0.0004784],
      [-0.00231,0.0009567,0],[-0.002398,0.0009931,-0.0004784],[-0.002648,0.001097,-0.0008839],[-0.003023,0.001252,-0.001155],
      [-0.003465,0.001435,-0.00125],[-0.003906,0.001618,-0.001155],[-0.004281,0.001773,-0.0008839],[-0.004531,0.001877,-0.0004784],
      [-0.005,0,0],[-0.004905,0,0.0004784],[-0.004634,0,0.0008839],[-0.004228,0,0.001155],
      [-0.00375,0,0.00125],[-0.003272,0,0.001155],[-0.002866,0,0.0008839],[-0.002595,0,0.0004784],
      [-0.0025,0,0],[-0.002595,0,-0.0004784],[-0.002866,0,-0.0008839],[-0.003272,0,-0.001155],
      [-0.00375,0,-0.00125],[-0.004228,0,-0.001155],[-0.004634,0,-0.0008839],[-0.004905,0,-0.0004784],
      [-0.004619,-0.001913,0],[-0.004531,-0.001877,0.0004784],[-0.004281,-0.001773,0.0008839],[-0.003906,-0.001618,0.001155],
      [-0.003465,-0.001435,0.00125],[-0.003023,-0.001252,0.001155],[-0.002648,-0.001097,0.0008839],[-0.002398,-0.0009931,0.0004784],
      [-0.00231,-0.0009567,0],[-0.002398,-0.0009931,-0.0004784],[-0.002648,-0.001097,-0.0008839],[-0.003023,-0.001252,-0.001155],
      [-0.003465,-0.001435,-0.00125],[-0.003906,-0.001618,-0.001155],[-0.004281,-0.001773,-0.0008839],[-0.004531,-0.001877,-0.0004784],
      [-0.003536,-0.003536,0],[-0.003468,-0.003468,0.0004784],[-0.003277,-0.003277,0.0008839],[-0.00299,-0.00299,0.001155],
      [-0.002652,-0.002652,0.00125],[-0.002313,-0.002313,0.001155],[-0.002027,-0.002027,0.0008839],[-0.001835,-0.001835,0.0004784],
      [-0.001768,-0.001768,0],[-0.001835,-0.001835,-0.0004784],[-0.002027,-0.002027,-0.0008839],[-0.002313,-0.002313,-0.001155],
      [-0.002652,-0.002652,-0.00125],[-0.00299,-0.00299,-0.001155],[-0.003277,-0.003277,-0.0008839],[-0.003468,-0.003468,-0.0004784],
      [-0.001913,-0.004619,0],[-0.001877,-0.004531,0.0004784],[-0.001773,-0.004281,0.0008839],[-0.001618,-0.003906,0.001155],
      [-0.001435,-0.003465,0.00125],[-0.001252,-0.003023,0.001155],[-0.001097,-0.002648,0.0008839],[-0.0009931,-0.002398,0.0004784],
      [-0.0009567,-0.00231,0],[-0.0009931,-0.002398,-0.0004784],[-0.001097,-0.002648,-0.0008839],[-0.001252,-0.003023,-0.001155],
      [-0.001435,-0.003465,-0.00125],[-0.001618,-0.003906,-0.001155],[-0.001773,-0.004281,-0.0008839],[-0.001877,-0.004531,-0.0004784],
      [0,-0.005,0],[0,-0.004905,0.0004784],[0,-0.004634,0.0008839],[0,-0.004228,0.001155],
      [0,-0.00375,0.00125],[0,-0.003272,0.001155],[0,-0.002866,0.0008839],[0,-0.002595,0.0004784],
      [0,-0.0025,0],[0,-0.002595,-0.0004784],[0,-0.002866,-0.0008839],[0,-0.003272,-0.001155],
      [0,-0.00375,-0.00125],[0,-0.004228,-0.001155],[0,-0.004634,-0.0008839],[0,-0.004905,-0.0004784],
      [0.001913,-0.004619,0],[0.001877,-0.004531,0.0004784],[0.001773,-0.004281,0.0008839],[0.001618,-0.003906,0.001155],
      [0.001435,-0.003465,0.00125],[0.001252,-0.003023,0.001155],[0.001097,-0.002648,0.0008839],[0.0009931,-0.002398,0.0004784],
      [0.0009567,-0.00231,0],[0.0009931,-0.002398,-0.0004784],[0.001097,-0.002648,-0.0008839],[0.001252,-0.003023,-0.001155],
      [0.001435,-0.003465,-0.00125],[0.001618,-0.003906,-0.001155],[0.001773,-0.004281,-0.0008839],[0.001877,-0.004531,-0.0004784],
      [0.003536,-0.003536,0],[0.003468,-0.003468,0.0004784],[0.003277,-0.003277,0.0008839],[0.00299,-0.00299,0.001155],
      [0.002652,-0.002652,0.00125],[0.002313,-0.002313,0.001155],[0.002027,-0.002027,0.0008839],[0.001835,-0.001835,0.0004784],
      [0.001768,-0.001768,0],[0.001835,-0.001835,-0.0004784],[0.002027,-0.002027,-0.0008839],[0.002313,-0.002313,-0.001155],
      [0.002652,-0.002652,-0.00125],[0.00299,-0.00299,-0.001155],[0.003277,-0.003277,-0.0008839],[0.003468,-0.003468,-0.0004784],
      [0.004619,-0.001913,0],[0.004531,-0.001877,0.0004784],[0.004281,-0.001773,0.0008839],[0.003906,-0.001618,0.001155],
      [0.003465,-0.001435,0.00125],[0.003023,-0.001252,0.001155],[0.002648,-0.001097,0.0008839],[0.002398,-0.0009931,0.0004784],
      [0.00231,-0.0009567,0],[0.002398,-0.0009931,-0.0004784],[0.002648,-0.001097,-0.0008839],[0.003023,-0.001252,-0.001155],
      [0.003465,-0.001435,-0.00125],[0.003906,-0.001618,-0.001155],[0.004281,-0.001773,-0.0008839],[0.004531,-0.001877,-0.0004784] ]

    fcs = [
      [0,16,17],[17,18,2],[18,19,3],[3,19,20],[4,20,21],[21,22,6],[22,23,7],[23,24,8],[24,25,9],[25,26,10],
      [26,27,11],[27,28,12],[28,29,13],[29,30,14],[14,30,31],[15,31,16],[32,33,17],[33,34,18],[34,35,19],[35,36,20],
      [36,37,21],[37,38,22],[22,38,39],[39,40,24],[24,40,41],[25,41,42],[26,42,43],[27,43,44],[44,45,29],[29,45,46],
      [30,46,47],[31,47,32],[48,49,33],[33,49,50],[50,51,35],[35,51,52],[52,53,37],[53,54,38],[38,54,55],[55,56,40],
      [56,57,41],[57,58,42],[58,59,43],[59,60,44],[44,60,61],[61,62,46],[62,63,47],[47,63,48],[64,65,49],[49,65,66],
      [50,66,67],[67,68,52],[68,69,53],[69,70,54],[54,70,71],[71,72,56],[72,73,57],[73,74,58],[74,75,59],[59,75,76],
      [76,77,61],[77,78,62],[78,79,63],[63,79,64],[80,81,65],[81,82,66],[82,83,67],[83,84,68],[84,85,69],[85,86,70],
      [86,87,71],[71,87,88],[88,89,73],[89,90,74],[74,90,91],[75,91,92],[92,93,77],[93,94,78],[78,94,95],[95,80,64],
      [80,96,97],[97,98,82],[98,99,83],[99,100,84],[100,101,85],[101,102,86],[102,103,87],[103,104,88],[88,104,105],
      [105,106,90],[90,106,107],[91,107,108],[108,109,93],[93,109,110],[110,111,95],[95,111,96],[112,113,97],
      [113,114,98],[114,115,99],[115,116,100],[116,117,101],[117,118,102],[118,119,103],[103,119,120],[120,121,105],
      [105,121,122],[122,123,107],[107,123,124],[124,125,109],[125,126,110],[126,127,111],[111,127,112],[128,129,113],
      [113,129,130],[114,130,131],[131,132,116],[132,133,117],[133,134,118],[118,134,135],[135,136,120],[120,136,137],
      [137,138,122],[138,139,123],[139,140,124],[140,141,125],[141,142,126],[142,143,127],[127,143,128],[128,144,145],
      [145,146,130],[146,147,131],[147,148,132],[148,149,133],[149,150,134],[150,151,135],[135,151,152],[152,153,137],
      [137,153,154],[154,155,139],[155,156,140],[156,157,141],[141,157,158],[158,159,143],[143,159,144],[144,160,161],
      [161,162,146],[146,162,163],[147,163,164],[148,164,165],[165,166,150],[166,167,151],[167,168,152],[152,168,169],
      [169,170,154],[154,170,171],[171,172,156],[172,173,157],[157,173,174],[158,174,175],[175,160,144],[176,177,161],
      [177,178,162],[162,178,179],[179,180,164],[164,180,181],[181,182,166],[166,182,183],[167,183,184],[184,185,169],
      [185,186,170],[186,187,171],[187,188,172],[188,189,173],[189,190,174],[174,190,191],[191,176,160],[192,193,177],
      [177,193,194],[194,195,179],[179,195,196],[180,196,197],[197,198,182],[182,198,199],[199,200,184],[200,201,185],
      [201,202,186],[186,202,203],[203,204,188],[204,205,189],[205,206,190],[206,207,191],[191,207,192],[192,208,209],
      [209,210,194],[210,211,195],[211,212,196],[196,212,213],[213,214,198],[214,215,199],[215,216,200],[216,217,201],
      [217,218,202],[202,218,219],[219,220,204],[220,221,205],[205,221,222],[206,222,223],[223,208,192],[224,225,209],
      [209,225,226],[226,227,211],[211,227,228],[228,229,213],[229,230,214],[214,230,231],[215,231,232],[232,233,217],
      [233,234,218],[218,234,235],[235,236,220],[236,237,221],[237,238,222],[238,239,223],[223,239,224],[240,241,225],
      [225,241,242],[226,242,243],[243,244,228],[244,245,229],[245,246,230],[246,247,231],[231,247,248],[248,249,233],
      [249,250,234],[250,251,235],[251,252,236],[236,252,253],[253,254,238],[254,255,239],[239,255,240],[0,1,241],
      [1,2,242],[2,3,243],[243,3,4],[4,5,245],[5,6,246],[6,7,247],[247,7,8],[8,9,249],[9,10,250],[250,10,11],
      [11,12,252],[12,13,253],[13,14,254],[14,15,255],[240,255,15],[1,0,17],[1,17,2],[2,18,3],[4,3,20],[5,4,21],
      [5,21,6],[6,22,7],[7,23,8],[8,24,9],[9,25,10],[10,26,11],[11,27,12],[12,28,13],[13,29,14],[15,14,31],
      [0,15,16],[16,32,17],[17,33,18],[18,34,19],[19,35,20],[20,36,21],[21,37,22],[23,22,39],[23,39,24],[25,24,41],
      [26,25,42],[27,26,43],[28,27,44],[28,44,29],[30,29,46],[31,30,47],[16,31,32],[32,48,33],[34,33,50],[34,50,35],
      [36,35,52],[36,52,37],[37,53,38],[39,38,55],[39,55,40],[40,56,41],[41,57,42],[42,58,43],[43,59,44],[45,44,61],
      [45,61,46],[46,62,47],[32,47,48],[48,64,49],[50,49,66],[51,50,67],[51,67,52],[52,68,53],[53,69,54],[55,54,71],
      [55,71,56],[56,72,57],[57,73,58],[58,74,59],[60,59,76],[60,76,61],[61,77,62],[62,78,63],[48,63,64],[64,80,65],
      [65,81,66],[66,82,67],[67,83,68],[68,84,69],[69,85,70],[70,86,71],[72,71,88],[72,88,73],[73,89,74],[75,74,91],
      [76,75,92],[76,92,77],[77,93,78],[79,78,95],[79,95,64],[81,80,97],[81,97,82],[82,98,83],[83,99,84],[84,100,85],
      [85,101,86],[86,102,87],[87,103,88],[89,88,105],[89,105,90],[91,90,107],[92,91,108],[92,108,93],[94,93,110],
      [94,110,95],[80,95,96],[96,112,97],[97,113,98],[98,114,99],[99,115,100],[100,116,101],[101,117,102],[102,118,103],
      [104,103,120],[104,120,105],[106,105,122],[106,122,107],[108,107,124],[108,124,109],[109,125,110],[110,126,111],
      [96,111,112],[112,128,113],[114,113,130],[115,114,131],[115,131,116],[116,132,117],[117,133,118],[119,118,135],
      [119,135,120],[121,120,137],[121,137,122],[122,138,123],[123,139,124],[124,140,125],[125,141,126],[126,142,127],
      [112,127,128],[129,128,145],[129,145,130],[130,146,131],[131,147,132],[132,148,133],[133,149,134],[134,150,135],
      [136,135,152],[136,152,137],[138,137,154],[138,154,139],[139,155,140],[140,156,141],[142,141,158],[142,158,143],
      [128,143,144],[145,144,161],[145,161,146],[147,146,163],[148,147,164],[149,148,165],[149,165,150],[150,166,151],
      [151,167,152],[153,152,169],[153,169,154],[155,154,171],[155,171,156],[156,172,157],[158,157,174],[159,158,175],
      [159,175,144],[160,176,161],[161,177,162],[163,162,179],[163,179,164],[165,164,181],[165,181,166],[167,166,183],
      [168,167,184],[168,184,169],[169,185,170],[170,186,171],[171,187,172],[172,188,173],[173,189,174],[175,174,191],
      [175,191,160],[176,192,177],[178,177,194],[178,194,179],[180,179,196],[181,180,197],[181,197,182],[183,182,199],
      [183,199,184],[184,200,185],[185,201,186],[187,186,203],[187,203,188],[188,204,189],[189,205,190],[190,206,191],
      [176,191,192],[193,192,209],[193,209,194],[194,210,195],[195,211,196],[197,196,213],[197,213,198],[198,214,199],
      [199,215,200],[200,216,201],[201,217,202],[203,202,219],[203,219,204],[204,220,205],[206,205,222],[207,206,223],
      [207,223,192],[208,224,209],[210,209,226],[210,226,211],[212,211,228],[212,228,213],[213,229,214],[215,214,231],
      [216,215,232],[216,232,217],[217,233,218],[219,218,235],[219,235,220],[220,236,221],[221,237,222],[222,238,223],
      [208,223,224],[224,240,225],[226,225,242],[227,226,243],[227,243,228],[228,244,229],[229,245,230],[230,246,231],
      [232,231,248],[232,248,233],[233,249,234],[234,250,235],[235,251,236],[237,236,253],[237,253,238],[238,254,239],
      [224,239,240],[240,0,241],[241,1,242],[242,2,243],[244,243,4],[244,4,245],[245,5,246],[246,6,247],[248,247,8],
      [248,8,249],[249,9,250],[251,250,11],[251,11,252],[252,12,253],[253,13,254],[254,14,255],[0,240,15] ]

    self.points = [];
    self.faces = [];
    for p in pts:
      self.points.append ( point ( size_scale*size_x*p[0], size_scale*size_y*p[1], size_scale*size_z*p[2] ) )
    for f in fcs:
      self.faces.append ( face ( f[0], f[1], f[2] ) )


class CellBlender_Sphere1 (plf_object):

  def __init__ ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    # Create an object of the requested size
    size_scale = 1

    self.points = [];
    self.faces = [];

    pts = [
      [0,0,-0.005],[0.003618,-0.002629,-0.002236],[-0.001382,-0.004253,-0.002236],[-0.004472,0,-0.002236],[-0.001382,0.004253,-0.002236],
      [0.003618,0.002629,-0.002236],[0.001382,-0.004253,0.002236],[-0.003618,-0.002629,0.002236],[-0.003618,0.002629,0.002236],
      [0.001382,0.004253,0.002236],[0.004472,0,0.002236],[0,0,0.005],[-0.0008123,-0.0025,-0.004253],[0.002127,-0.001545,-0.004253],
      [0.001314,-0.004045,-0.002629],[0.002127,0.001545,-0.004253],[0.004253,0,-0.002629],[-0.002629,0,-0.004253],
      [-0.003441,-0.0025,-0.002629],[-0.0008123,0.0025,-0.004253],[-0.003441,0.0025,-0.002629],[0.001314,0.004045,-0.002629],
      [0.004755,0.001545,0],[0.004755,-0.001545,0],[0.002939,-0.004045,0],[0,-0.005,0],[-0.002939,-0.004045,0],
      [-0.004755,-0.001545,0],[-0.004755,0.001545,0],[-0.002939,0.004045,0],[0,0.005,0],[0.002939,0.004045,0],
      [0.003441,-0.0025,0.002629],[-0.001314,-0.004045,0.002629],[-0.004253,0,0.002629],[-0.001314,0.004045,0.002629],
      [0.003441,0.0025,0.002629],[0.002629,0,0.004253],[0.0008123,-0.0025,0.004253],[-0.002127,-0.001545,0.004253],
      [-0.002127,0.001545,0.004253],[0.0008123,0.0025,0.004253] ]

    fcs = [
      [14,2,12],[12,13,14],[1,14,13],[12,0,13],[16,1,13],[13,15,16],[5,16,15],[13,0,15],[18,3,17],[17,12,18],
      [2,18,12],[17,0,12],[20,4,19],[19,17,20],[3,20,17],[19,0,17],[21,5,15],[15,19,21],[4,21,19],[15,0,19],
      [23,1,16],[16,22,23],[10,23,22],[22,16,5],[25,2,14],[14,24,25],[6,25,24],[24,14,1],[27,3,18],[18,26,27],
      [7,27,26],[26,18,2],[29,4,20],[20,28,29],[8,29,28],[28,20,3],[31,5,21],[21,30,31],[9,31,30],[30,21,4],
      [32,6,24],[24,23,32],[10,32,23],[23,24,1],[33,7,26],[26,25,33],[6,33,25],[25,26,2],[34,8,28],[28,27,34],
      [7,34,27],[27,28,3],[35,9,30],[30,29,35],[8,35,29],[29,30,4],[36,10,22],[22,31,36],[9,36,31],[31,22,5],
      [38,6,32],[32,37,38],[11,38,37],[37,32,10],[39,7,33],[33,38,39],[11,39,38],[38,33,6],[40,8,34],[34,39,40],
      [11,40,39],[39,34,7],[41,9,35],[35,40,41],[11,41,40],[40,35,8],[37,10,36],[36,41,37],[11,37,41],[41,36,9] ]

    self.points = [];
    self.faces = [];
    for p in pts:
      self.points.append ( point ( size_scale*size_x*p[0], size_scale*size_y*p[1], size_scale*size_z*p[2] ) )
    for f in fcs:
      self.faces.append ( face ( f[0], f[1], f[2] ) )


class CellBlender_Sphere2 (plf_object):

  def __init__ ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    # Create an object of the requested size
    size_scale = 1

    self.points = [];
    self.faces = [];

    pts = [
      [0,0,-0.005],[0.003618,-0.002629,-0.002236],[-0.001382,-0.004253,-0.002236],[-0.004472,0,-0.002236],[-0.001382,0.004253,-0.002236],
      [0.003618,0.002629,-0.002236],[0.001382,-0.004253,0.002236],[-0.003618,-0.002629,0.002236],[-0.003618,0.002629,0.002236],
      [0.001382,0.004253,0.002236],[0.004472,0,0.002236],[0,0,0.005],[-0.0008123,-0.0025,-0.004253],[0.002127,-0.001545,-0.004253],
      [0.001314,-0.004045,-0.002629],[0.002127,0.001545,-0.004253],[0.004253,0,-0.002629],[-0.002629,0,-0.004253],
      [-0.003441,-0.0025,-0.002629],[-0.0008123,0.0025,-0.004253],[-0.003441,0.0025,-0.002629],[0.001314,0.004045,-0.002629],
      [0.004755,0.001545,0],[0.004755,-0.001545,0],[0.002939,-0.004045,0],[0,-0.005,0],[-0.002939,-0.004045,0],
      [-0.004755,-0.001545,0],[-0.004755,0.001545,0],[-0.002939,0.004045,0],[0,0.005,0],[0.002939,0.004045,0],
      [0.003441,-0.0025,0.002629],[-0.001314,-0.004045,0.002629],[-0.004253,0,0.002629],[-0.001314,0.004045,0.002629],
      [0.003441,0.0025,0.002629],[0.002629,0,0.004253],[0.0008123,-0.0025,0.004253],[-0.002127,-0.001545,0.004253],
      [-0.002127,0.001545,0.004253],[0.0008123,0.0025,0.004253],[-0.001141,-0.00351,-0.003373],[-0.0004222,-0.001299,-0.00481],
      [0.002986,-0.002169,-0.003373],[0.001105,-0.0008031,-0.00481],[-3.513e-05,-0.004313,-0.002529],[0.002564,-0.003469,-0.002529],
      [0.002986,0.002169,-0.003373],[0.001105,0.0008031,-0.00481],[0.004091,-0.001366,-0.002529],[0.004091,0.001366,-0.002529],
      [-0.003691,0,-0.003373],[-0.001366,0,-0.00481],[-0.002507,-0.00351,-0.002529],[-0.004113,-0.001299,-0.002529],
      [-0.001141,0.00351,-0.003373],[-0.0004222,0.001299,-0.00481],[-0.002507,0.00351,-0.002529],[-0.004113,0.001299,-0.002529],
      [-3.513e-05,0.004313,-0.002529],[0.002564,0.003469,-0.002529],[0.004352,0.002169,-0.001162],[0.004796,0.0008031,0.001162],
      [0.004352,-0.002169,-0.001162],[0.004796,-0.0008031,0.001162],[0.003408,-0.003469,-0.001162],[0.002246,-0.004313,0.001162],
      [-0.0007183,-0.00481,-0.001162],[0.0007183,-0.00481,0.001162],[-0.002246,-0.004313,-0.001162],[-0.003408,-0.003469,0.001162],
      [-0.004352,-0.002169,0.001162],[-0.004796,-0.0008031,-0.001162],[-0.004352,0.002169,0.001162],[-0.004796,0.0008031,-0.001162],
      [-0.002246,0.004313,-0.001162],[-0.003408,0.003469,0.001162],[0.0007183,0.00481,0.001162],[-0.0007183,0.00481,-0.001162],
      [0.002246,0.004313,0.001162],[0.003408,0.003469,-0.001162],[0.002507,-0.00351,0.002529],[0.004113,-0.001299,0.002529],
      [-0.002564,-0.003469,0.002529],[3.513e-05,-0.004313,0.002529],[-0.004091,-0.001366,0.002529],[-0.004091,0.001366,0.002529],
      [3.513e-05,0.004313,0.002529],[-0.002564,0.003469,0.002529],[0.002507,0.00351,0.002529],[0.004113,0.001299,0.002529],
      [0.001366,0,0.00481],[0.003691,0,0.003373],[0.001141,-0.00351,0.003373],[0.0004222,-0.001299,0.00481],
      [-0.002986,-0.002169,0.003373],[-0.001105,-0.0008031,0.00481],[-0.002986,0.002169,0.003373],[-0.001105,0.0008031,0.00481],
      [0.001141,0.00351,0.003373],[0.0004222,0.001299,0.00481],[0.000264,-0.003441,-0.003618],[0.000691,-0.002127,-0.004472],
      [0.001809,-0.002939,-0.003618],[0.003354,-0.0008123,-0.003618],[0.002236,0,-0.004472],[0.003354,0.0008123,-0.003618],
      [-0.003191,-0.001314,-0.003618],[-0.001809,-0.001314,-0.004472],[-0.002236,-0.002629,-0.003618],[-0.002236,0.002629,-0.003618],
      [-0.001809,0.001314,-0.004472],[-0.003191,0.001314,-0.003618],[0.001809,0.002939,-0.003618],[0.000691,0.002127,-0.004472],
      [0.000264,0.003441,-0.003618],[0.004736,-0.0008123,-0.001382],[0.004736,0.0008123,-0.001382],[0.005,0,0],
      [0.000691,-0.004755,-0.001382],[0.002236,-0.004253,-0.001382],[0.001545,-0.004755,0],[-0.004309,-0.002127,-0.001382],
      [-0.003354,-0.003441,-0.001382],[-0.004045,-0.002939,0],[-0.003354,0.003441,-0.001382],[-0.004309,0.002127,-0.001382],
      [-0.004045,0.002939,0],[0.002236,0.004253,-0.001382],[0.000691,0.004755,-0.001382],[0.001545,0.004755,0],
      [0.003354,-0.003441,0.001382],[0.004045,-0.002939,0],[0.004309,-0.002127,0.001382],[-0.002236,-0.004253,0.001382],
      [-0.001545,-0.004755,0],[-0.000691,-0.004755,0.001382],[-0.004736,0.0008123,0.001382],[-0.005,0,0],[-0.004736,-0.0008123,0.001382],
      [-0.000691,0.004755,0.001382],[-0.001545,0.004755,0],[-0.002236,0.004253,0.001382],[0.004309,0.002127,0.001382],
      [0.004045,0.002939,0],[0.003354,0.003441,0.001382],[0.002236,-0.002629,0.003618],[0.003191,-0.001314,0.003618],
      [0.001809,-0.001314,0.004472],[-0.001809,-0.002939,0.003618],[-0.000264,-0.003441,0.003618],[-0.000691,-0.002127,0.004472],
      [-0.003354,0.0008123,0.003618],[-0.003354,-0.0008123,0.003618],[-0.002236,0,0.004472],[-0.000264,0.003441,0.003618],
      [-0.001809,0.002939,0.003618],[-0.000691,0.002127,0.004472],[0.003191,0.001314,0.003618],[0.002236,0.002629,0.003618],
      [0.001809,0.001314,0.004472] ]

    fcs = [
      [102,14,46],[46,42,102],[12,102,42],[42,46,2],[102,12,103],[103,104,102],[14,102,104],[104,103,13],[44,1,47],
      [47,104,44],[13,44,104],[104,47,14],[45,13,103],[103,43,45],[0,45,43],[43,103,12],[105,16,50],[50,44,105],
      [13,105,44],[44,50,1],[105,13,106],[106,107,105],[16,105,107],[107,106,15],[48,5,51],[51,107,48],[15,48,107],
      [107,51,16],[49,15,106],[106,45,49],[0,49,45],[45,106,13],[108,18,55],[55,52,108],[17,108,52],[52,55,3],
      [108,17,109],[109,110,108],[18,108,110],[110,109,12],[42,2,54],[54,110,42],[12,42,110],[110,54,18],[43,12,109],
      [109,53,43],[0,43,53],[53,109,17],[111,20,58],[58,56,111],[19,111,56],[56,58,4],[111,19,112],[112,113,111],
      [20,111,113],[113,112,17],[52,3,59],[59,113,52],[17,52,113],[113,59,20],[53,17,112],[112,57,53],[0,53,57],
      [57,112,19],[114,21,61],[61,48,114],[15,114,48],[48,61,5],[114,15,115],[115,116,114],[21,114,116],[116,115,19],
      [56,4,60],[60,116,56],[19,56,116],[116,60,21],[57,19,115],[115,49,57],[0,57,49],[49,115,15],[117,23,64],
      [64,50,117],[16,117,50],[50,64,1],[117,16,118],[118,119,117],[23,117,119],[119,118,22],[63,10,65],[65,119,63],
      [22,63,119],[119,65,23],[62,22,118],[118,51,62],[5,62,51],[51,118,16],[120,25,68],[68,46,120],[14,120,46],
      [46,68,2],[120,14,121],[121,122,120],[25,120,122],[122,121,24],[67,6,69],[69,122,67],[24,67,122],[122,69,25],
      [66,24,121],[121,47,66],[1,66,47],[47,121,14],[123,27,73],[73,55,123],[18,123,55],[55,73,3],[123,18,124],
      [124,125,123],[27,123,125],[125,124,26],[71,7,72],[72,125,71],[26,71,125],[125,72,27],[70,26,124],[124,54,70],
      [2,70,54],[54,124,18],[126,29,76],[76,58,126],[20,126,58],[58,76,4],[126,20,127],[127,128,126],[29,126,128],
      [128,127,28],[74,8,77],[77,128,74],[28,74,128],[128,77,29],[75,28,127],[127,59,75],[3,75,59],[59,127,20],
      [129,31,81],[81,61,129],[21,129,61],[61,81,5],[129,21,130],[130,131,129],[31,129,131],[131,130,30],[78,9,80],
      [80,131,78],[30,78,131],[131,80,31],[79,30,130],[130,60,79],[4,79,60],[60,130,21],[132,32,82],[82,67,132],
      [24,132,67],[67,82,6],[132,24,133],[133,134,132],[32,132,134],[134,133,23],[65,10,83],[83,134,65],[23,65,134],
      [134,83,32],[64,23,133],[133,66,64],[1,64,66],[66,133,24],[135,33,84],[84,71,135],[26,135,71],[71,84,7],
      [135,26,136],[136,137,135],[33,135,137],[137,136,25],[69,6,85],[85,137,69],[25,69,137],[137,85,33],[68,25,136],
      [136,70,68],[2,68,70],[70,136,26],[138,34,87],[87,74,138],[28,138,74],[74,87,8],[138,28,139],[139,140,138],
      [34,138,140],[140,139,27],[72,7,86],[86,140,72],[27,72,140],[140,86,34],[73,27,139],[139,75,73],[3,73,75],
      [75,139,28],[141,35,88],[88,78,141],[30,141,78],[78,88,9],[141,30,142],[142,143,141],[35,141,143],[143,142,29],
      [77,8,89],[89,143,77],[29,77,143],[143,89,35],[76,29,142],[142,79,76],[4,76,79],[79,142,30],[144,36,91],
      [91,63,144],[22,144,63],[63,91,10],[144,22,145],[145,146,144],[36,144,146],[146,145,31],[80,9,90],[90,146,80],
      [31,80,146],[146,90,36],[81,31,145],[145,62,81],[5,81,62],[62,145,22],[147,38,94],[94,82,147],[32,147,82],
      [82,94,6],[147,32,148],[148,149,147],[38,147,149],[149,148,37],[92,11,95],[95,149,92],[37,92,149],[149,95,38],
      [93,37,148],[148,83,93],[10,93,83],[83,148,32],[150,39,96],[96,84,150],[33,150,84],[84,96,7],[150,33,151],
      [151,152,150],[39,150,152],[152,151,38],[95,11,97],[97,152,95],[38,95,152],[152,97,39],[94,38,151],[151,85,94],
      [6,94,85],[85,151,33],[153,40,98],[98,87,153],[34,153,87],[87,98,8],[153,34,154],[154,155,153],[40,153,155],
      [155,154,39],[97,11,99],[99,155,97],[39,97,155],[155,99,40],[96,39,154],[154,86,96],[7,96,86],[86,154,34],
      [156,41,100],[100,88,156],[35,156,88],[88,100,9],[156,35,157],[157,158,156],[41,156,158],[158,157,40],
      [99,11,101],[101,158,99],[40,99,158],[158,101,41],[98,40,157],[157,89,98],[8,98,89],[89,157,35],[159,37,93],
      [93,91,159],[36,159,91],[91,93,10],[159,36,160],[160,161,159],[37,159,161],[161,160,41],[101,11,92],[92,161,101],
      [41,101,161],[161,92,37],[100,41,160],[160,90,100],[9,100,90],[90,160,36] ]

    self.points = [];
    self.faces = [];
    for p in pts:
      self.points.append ( point ( size_scale*size_x*p[0], size_scale*size_y*p[1], size_scale*size_z*p[2] ) )
    for f in fcs:
      self.faces.append ( face ( f[0], f[1], f[2] ) )


class CellBlender_Receptor (plf_object):

  def __init__ ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    # Create an object of the requested size
    size_scale = 1

    self.points = [];
    self.faces = [];

    pts = [
      [0,0.004956,0.001781],[0,0.005,0.002473],[0,0.005,0.003012],[0,0.004996,0.00341],
      [0,0.004962,0.003742],[0,0.004854,0.004061],[0.004755,0.001545,0.003012],[0.003794,0.001233,-0.005168],
      [0.003914,0.001272,-0.005065],[0.003673,0.001194,-0.005233],[0.004003,0.001301,-0.004882],[0.004,0.0013,-0.004477],
      [0.003829,0.001244,-0.003764],[0.003536,0.001149,-0.002894],[0.003387,0.001101,-0.001916],[0.003591,0.001167,-0.0009425],
      [0.004011,0.001303,1.023e-05],[0.004451,0.001446,0.000946],[0.004714,0.001531,0.001781],[0.004755,0.001545,0.002473],
      [0.004751,0.001544,0.00341],[0.004719,0.001533,0.003742],[0.004617,0.0015,0.004061],[0.004407,0.001432,0.004363],
      [0.00413,0.001342,0.004584],[0.003888,0.001263,0.004691],[0.003707,0.001205,0.004725],[0.003566,0.001159,0.004729],
      [0.003425,0.001113,0.004725],[0.003245,0.001055,0.004691],[0.003002,0.0009759,0.004584],[0.002725,0.0008859,0.004363],
      [0.002516,0.0008178,0.004061],[0.002413,0.0007846,0.003742],[0.002381,0.0007742,0.00341],[0.002377,0.0007729,0.003012],
      [0.002377,0.0007729,0.002473],[0.002377,0.0007729,0.001781],[0.002351,0.0007643,0.000946],[0.002182,0.0007094,1.023e-05],
      [0.00199,0.0006471,-0.0009479],[0.001926,0.0006265,-0.001952],[0.002096,0.0006817,-0.002979],[0.002453,0.0007975,-0.003869],
      [0.002815,0.000915,-0.004438],[0.003073,0.0009989,-0.004872],[0.00324,0.001053,-0.005094],[0.003356,0.001091,-0.005186],
      [0.003458,0.001124,-0.005237],[0.003561,0.001157,-0.005256],[0.002853,-0.003927,0.004061],[0.002916,-0.004014,0.003742],
      [0.002936,-0.004042,0.00341],[0.002939,-0.004045,0.002473],[0.002913,-0.00401,0.001781],[0.002751,-0.003786,0.000946],
      [0.002939,-0.004045,0.003012],[0.002345,-0.003228,-0.005168],[0.002419,-0.00333,-0.005065],[0.002474,-0.003405,-0.004882],
      [0.002472,-0.003403,-0.004477],[0.002367,-0.003257,-0.003764],[0.002185,-0.003008,-0.002894],[0.002094,-0.002881,-0.001916],
      [0.00222,-0.003055,-0.0009425],[0.002479,-0.003412,1.023e-05],[0.002724,-0.003749,0.004363],[0.002553,-0.003513,0.004584],
      [0.002403,-0.003307,0.004691],[0.002291,-0.003154,0.004725],[0.002204,-0.003034,0.004729],[0.002117,-0.002914,0.004725],
      [0.002006,-0.002761,0.004691],[0.001856,-0.002554,0.004584],[0.001685,-0.002319,0.004363],[0.001555,-0.00214,0.004061],
      [0.001492,-0.002053,0.003742],[0.001472,-0.002026,0.00341],[0.001469,-0.002023,0.003012],[0.001469,-0.002023,0.002473],
      [0.001469,-0.002023,0.001781],[0.001453,-0.002,0.000946],[0.001349,-0.001856,1.023e-05],[0.00123,-0.001693,-0.0009479],
      [0.001191,-0.001639,-0.001952],[0.001296,-0.001784,-0.002979],[0.001516,-0.002087,-0.003869],[0.00174,-0.002395,-0.004438],
      [0.0019,-0.002615,-0.004872],[0.002003,-0.002757,-0.005094],[0.002074,-0.002855,-0.005186],[0.002137,-0.002942,-0.005237],
      [0.002201,-0.00303,-0.005256],[0.00227,-0.003125,-0.005233],[-0.002939,-0.004045,0.003012],[-0.002939,-0.004045,0.002473],
      [-0.002937,-0.004042,0.00341],[-0.003561,0.001157,-0.005256],[-0.003458,0.001123,-0.005237],[-0.003356,0.00109,-0.005186],
      [-0.00324,0.001053,-0.005094],[-0.003074,0.0009984,-0.004872],[-0.002815,0.0009143,-0.004438],[-0.002453,0.0007967,-0.003869],
      [-0.002097,0.0006808,-0.002979],[-0.001927,0.0006255,-0.001952],[-0.00199,0.0006461,-0.0009479],[-0.002182,0.0007085,1.023e-05],
      [-0.002351,0.0007634,0.000946],[-0.002377,0.000772,0.001781],[-0.002377,0.000772,0.002473],[-0.002377,0.000772,0.003012],
      [-0.002381,0.0007733,0.00341],[-0.002414,0.0007838,0.003742],[-0.002516,0.000817,0.004061],[-0.002726,0.0008852,0.004363],
      [-0.003003,0.0009753,0.004584],[-0.003245,0.001054,0.004691],[-0.003425,0.001113,0.004725],[-0.003566,0.001159,0.004729],
      [-0.003708,0.001204,0.004725],[-0.003888,0.001263,0.004691],[-0.00413,0.001342,0.004584],[-0.004011,0.001303,1.023e-05],
      [-0.003591,0.001167,-0.0009425],[-0.003387,0.0011,-0.001916],[-0.003536,0.001149,-0.002894],[-0.003829,0.001244,-0.003764],
      [-0.004,0.0013,-0.004477],[-0.004003,0.001301,-0.004882],[-0.003673,0.001193,-0.005233],[-0.003914,0.001272,-0.005065],
      [-0.003794,0.001233,-0.005168],[-0.00227,-0.003125,-0.005233],[-0.002201,-0.00303,-0.005256],[-0.002137,-0.002942,-0.005237],
      [-0.002074,-0.002855,-0.005186],[-0.002003,-0.002757,-0.005094],[-0.0019,-0.002615,-0.004872],[-0.00174,-0.002395,-0.004438],
      [-0.001516,-0.002087,-0.003869],[-0.001296,-0.001784,-0.002979],[-0.001191,-0.001639,-0.001952],[-0.00123,-0.001693,-0.0009479],
      [-0.001349,-0.001856,1.023e-05],[-0.001453,-0.002,0.000946],[-0.001469,-0.002023,0.001781],[-0.001469,-0.002023,0.002473],
      [-0.001469,-0.002023,0.003012],[-0.001472,-0.002026,0.00341],[-0.001492,-0.002053,0.003742],[-0.001555,-0.00214,0.004061],
      [-0.001685,-0.002319,0.004363],[-0.001856,-0.002554,0.004584],[-0.002006,-0.002761,0.004691],[-0.002117,-0.002914,0.004725],
      [-0.002204,-0.003034,0.004729],[-0.002291,-0.003154,0.004725],[-0.002403,-0.003307,0.004691],[-0.002553,-0.003513,0.004584],
      [-0.002724,-0.003749,0.004363],[-0.002853,-0.003927,0.004061],[-0.002917,-0.004014,0.003742],[-0.002913,-0.00401,0.001781],
      [-0.002751,-0.003786,0.000946],[-0.002479,-0.003412,1.023e-05],[-0.00222,-0.003055,-0.0009425],[-0.002094,-0.002881,-0.001916],
      [-0.002185,-0.003008,-0.002894],[-0.002367,-0.003257,-0.003764],[-0.002472,-0.003403,-0.004477],[-0.002474,-0.003405,-0.004882],
      [-0.002419,-0.00333,-0.005065],[-0.002345,-0.003228,-0.005168],[-0.004451,0.001446,0.000946],[-0.004714,0.001532,0.001781],
      [-0.004755,0.001545,0.002473],[-0.004755,0.001545,0.003012],[-0.004751,0.001544,0.00341],[-0.004719,0.001533,0.003742],
      [-0.004617,0.0015,0.004061],[-0.004407,0.001432,0.004363],[-1.314e-07,0.00399,-0.005168],[-1.041e-07,0.004116,-0.005065],
      [-1.586e-07,0.003862,-0.005233],[0,0.004209,-0.004882],[0,0.004206,-0.004477],[-1.232e-07,0.004026,-0.003764],
      [-1.892e-07,0.003718,-0.002894],[-2.225e-07,0.003561,-0.001916],[-1.764e-07,0.003776,-0.0009425],[0,0.004217,1.023e-05],
      [0,0.00468,0.000946],[0,0.004634,0.004363],[0,0.004343,0.004584],[-1.106e-07,0.004088,0.004691],
      [-1.513e-07,0.003898,0.004725],[-1.829e-07,0.00375,0.004729],[-2.145e-07,0.003601,0.004725],[-2.545e-07,0.003412,0.004691],
      [-3.088e-07,0.003157,0.004584],[-3.719e-07,0.002866,0.004363],[-4.195e-07,0.002645,0.004061],[-4.426e-07,0.002538,0.003742],
      [-4.498e-07,0.002504,0.00341],[-4.507e-07,0.0025,0.003012],[-4.507e-07,0.0025,0.002473],[-4.508e-07,0.0025,0.001781],
      [-4.566e-07,0.002472,0.000946],[-4.945e-07,0.002294,1.023e-05],[-5.379e-07,0.002092,-0.0009479],[-5.521e-07,0.002026,-0.001952],
      [-5.142e-07,0.002205,-0.002979],[-4.335e-07,0.002579,-0.003869],[-3.512e-07,0.00296,-0.004438],[-2.932e-07,0.003232,-0.004872],
      [-2.55e-07,0.003407,-0.005094],[-2.299e-07,0.003529,-0.005186],[-2.073e-07,0.003636,-0.005237],[-1.84e-07,0.003745,-0.005256] ]

    fcs = [
      [19,2,6],[1,2,19],[20,6,2],[20,2,3],[52,6,20],[52,56,6],[19,6,53],[53,6,56],[95,56,94],[53,56,95],[96,94,56],
      [96,56,52],[178,94,96],[178,177,94],[95,94,176],[176,94,177],[1,177,2],[176,177,1],[3,2,177],[3,177,178],
      [97,130,219],[219,130,184],[98,97,218],[218,97,219],[99,98,217],[217,98,218],[100,99,216],[216,99,217],
      [101,100,215],[215,100,216],[102,101,214],[214,101,215],[103,102,213],[213,102,214],[104,103,212],[212,103,213],
      [105,104,211],[211,104,212],[106,211,210],[106,105,211],[107,210,209],[107,106,210],[108,209,208],[108,107,209],
      [109,208,207],[109,108,208],[110,207,206],[110,109,207],[111,206,205],[111,110,206],[112,205,204],[112,111,205],
      [113,204,203],[113,112,204],[114,203,202],[114,113,203],[115,202,201],[115,114,202],[116,201,200],[116,115,201],
      [117,200,199],[117,116,200],[118,199,198],[118,117,199],[119,198,197],[119,118,198],[120,197,196],[120,119,197],
      [121,196,195],[121,120,196],[122,195,194],[122,121,195],[181,194,193],[181,122,194],[180,193,5],[180,181,193],
      [179,5,4],[179,180,5],[178,4,3],[178,179,4],[175,1,0],[175,176,1],[174,175,192],[192,175,0],[123,174,191],
      [191,174,192],[124,123,190],[190,123,191],[125,124,189],[189,124,190],[126,189,188],[126,125,189],[127,188,187],
      [127,126,188],[128,187,186],[128,127,187],[129,186,185],[129,128,186],[131,129,183],[183,129,185],[132,182,184],
      [132,184,130],[132,131,182],[182,131,183],[173,172,132],[132,172,131],[173,132,130],[173,130,133],[172,171,131],
      [131,171,129],[171,128,129],[171,170,128],[170,127,128],[170,169,127],[169,126,127],[169,168,126],[168,125,126],
      [168,167,125],[167,166,125],[125,166,124],[166,165,124],[124,165,123],[165,164,123],[123,164,174],[164,163,174],
      [174,163,175],[163,95,175],[175,95,176],[96,179,178],[96,162,179],[162,180,179],[162,161,180],[161,181,180],
      [161,160,181],[160,122,181],[160,159,122],[159,121,122],[159,158,121],[158,120,121],[158,157,120],[157,119,120],
      [157,156,119],[156,118,119],[156,155,118],[155,117,118],[155,154,117],[154,116,117],[154,153,116],[153,115,116],
      [153,152,115],[152,114,115],[152,151,114],[151,113,114],[151,150,113],[150,112,113],[150,149,112],[149,111,112],
      [149,148,111],[148,110,111],[148,147,110],[147,109,110],[147,146,109],[146,108,109],[146,145,108],[145,107,108],
      [145,144,107],[144,106,107],[144,143,106],[143,105,106],[143,142,105],[142,141,105],[105,141,104],[141,140,104],
      [104,140,103],[140,139,103],[103,139,102],[139,138,102],[102,138,101],[138,137,101],[101,137,100],[137,136,100],
      [100,136,99],[136,135,99],[99,135,98],[135,134,98],[98,134,97],[134,133,97],[97,133,130],[92,133,134],
      [92,93,133],[91,92,135],[135,92,134],[90,135,136],[90,91,135],[89,136,137],[89,90,136],[88,137,138],[88,89,137],
      [87,138,139],[87,88,138],[86,139,140],[86,87,139],[85,140,141],[85,86,140],[84,141,142],[84,85,141],[83,142,143],
      [83,84,142],[82,143,144],[82,83,143],[81,144,145],[81,82,144],[80,145,146],[80,81,145],[79,146,147],[79,80,146],
      [78,147,148],[78,79,147],[77,148,149],[77,78,148],[76,149,150],[76,77,149],[75,150,151],[75,76,150],[74,151,152],
      [74,75,151],[73,152,153],[73,74,152],[72,153,154],[72,73,153],[71,154,155],[71,72,154],[70,155,156],[70,71,155],
      [69,156,157],[69,70,156],[68,157,158],[68,69,157],[67,158,159],[67,68,158],[66,67,160],[160,67,159],[50,160,161],
      [50,66,160],[51,161,162],[51,50,161],[52,162,96],[52,51,162],[54,53,163],[163,53,95],[55,54,164],[164,54,163],
      [65,55,165],[165,55,164],[64,165,166],[64,65,165],[63,166,167],[63,64,166],[62,167,168],[62,63,167],[61,168,169],
      [61,62,168],[60,169,170],[60,61,169],[59,170,171],[59,60,170],[58,171,172],[58,59,171],[57,173,133],[57,133,93],
      [57,58,173],[173,58,172],[7,8,57],[57,8,58],[7,57,93],[7,93,9],[8,10,58],[58,10,59],[10,60,59],[10,11,60],
      [11,61,60],[11,12,61],[12,62,61],[12,13,62],[13,63,62],[13,14,63],[14,15,63],[63,15,64],[15,16,64],[64,16,65],
      [16,17,65],[65,17,55],[17,18,55],[55,18,54],[18,19,54],[54,19,53],[20,51,52],[20,21,51],[21,50,51],[21,22,50],
      [22,66,50],[22,23,66],[23,67,66],[23,24,67],[24,68,67],[24,25,68],[25,69,68],[25,26,69],[26,70,69],[26,27,70],
      [27,71,70],[27,28,71],[28,72,71],[28,29,72],[29,73,72],[29,30,73],[30,74,73],[30,31,74],[31,75,74],[31,32,75],
      [32,76,75],[32,33,76],[33,77,76],[33,34,77],[34,78,77],[34,35,78],[35,79,78],[35,36,79],[36,80,79],[36,37,80],
      [37,81,80],[37,38,81],[38,82,81],[38,39,82],[39,83,82],[39,40,83],[40,84,83],[40,41,84],[41,42,84],[84,42,85],
      [42,43,85],[85,43,86],[43,44,86],[86,44,87],[44,45,87],[87,45,88],[45,46,88],[88,46,89],[46,47,89],[89,47,90],
      [47,48,90],[90,48,91],[48,49,91],[91,49,92],[49,9,92],[92,9,93],[219,184,49],[49,184,9],[218,219,48],
      [48,219,49],[217,218,47],[47,218,48],[216,217,46],[46,217,47],[215,216,45],[45,216,46],[214,215,44],[44,215,45],
      [213,214,43],[43,214,44],[212,213,42],[42,213,43],[211,212,41],[41,212,42],[210,41,40],[210,211,41],[209,40,39],
      [209,210,40],[208,39,38],[208,209,39],[207,38,37],[207,208,38],[206,37,36],[206,207,37],[205,36,35],[205,206,36],
      [204,35,34],[204,205,35],[203,34,33],[203,204,34],[202,33,32],[202,203,33],[201,32,31],[201,202,32],[200,31,30],
      [200,201,31],[199,30,29],[199,200,30],[198,29,28],[198,199,29],[197,28,27],[197,198,28],[196,27,26],[196,197,27],
      [195,26,25],[195,196,26],[194,25,24],[194,195,25],[193,24,23],[193,194,24],[5,23,22],[5,193,23],[4,22,21],
      [4,5,22],[3,21,20],[3,4,21],[0,1,18],[18,1,19],[17,192,0],[18,17,0],[191,192,16],[16,192,17],[190,191,15],
      [15,191,16],[189,190,14],[14,190,15],[188,14,13],[188,189,14],[187,13,12],[187,188,13],[186,12,11],[186,187,12],
      [185,11,10],[185,186,11],[183,185,8],[8,185,10],[182,7,9],[182,9,184],[182,183,7],[7,183,8] ]

    self.points = [];
    self.faces = [];
    for p in pts:
      self.points.append ( point ( size_scale*size_x*p[0], size_scale*size_y*p[1], size_scale*size_z*p[2] ) )
    for f in fcs:
      self.faces.append ( face ( f[0], f[1], f[2] ) )



class plf_object_flat (plf_object):

  def xor_to_set ( self, s, l ):
    # Use "xor" logic to add a line if it's not there, but remove it if it is there
    # The removal check needs to check both orderings of the points in the line
    found = False
    if l in s:
      # print ( "Found in normal order and removed" )
      found = True
      s.remove(l)
    else:
      ll = (l[1],l[0])
      if ll in s:
        # print ( "Found in reverse order and removed" )
        found = True
        s.remove(ll)
    if not found:
      s |= { l }
    

  def build_from_2D ( self, points_2d, faces_2d, thickness, size_x=1.0, size_y=1.0, size_z=1.0 ):

    self.points = [];
    self.faces = [];

    np = len(points_2d)

    # Start by ensuring that all of the 2D faces have normals facing up
    for f in faces_2d:

      #print ( "p1(%d) = ( %0.3f, %0.3f )" % (f[0], points_2d[f[0]][0], points_2d[f[0]][1]) )
      #print ( "p2(%d) = ( %0.3f, %0.3f )" % (f[1], points_2d[f[1]][0], points_2d[f[1]][1]) )
      #print ( "p3(%d) = ( %0.3f, %0.3f )" % (f[2], points_2d[f[2]][0], points_2d[f[2]][1]) )

      # Compute the portion of the cross product needed for z
      u1 = points_2d[f[1]][0] - points_2d[f[0]][0]
      v1 = points_2d[f[1]][1] - points_2d[f[0]][1]
      u2 = points_2d[f[2]][0] - points_2d[f[0]][0]
      v2 = points_2d[f[2]][1] - points_2d[f[0]][1]
      cross = (u1*v2) - (u2*v1)
      #print ( "uv = " + str(u1) + " " + str(v1) + " " + str(u2) + " " + str(v2) )
      #print ( "Cross = " + str(cross) )
      if cross < 0:
        # Swap the order of the points to flip the normal
        #print ( "Swapping " + str(f) )
        temp = f[2]
        f[2] = f[1]
        f[1] = temp


    # Create a set of all the lines which appear only once - the "edges" that need to be extruded
    v = set()
    
    # Go through all of the faces and the lines in each face
    for f in faces_2d:
      # Use "xor" logic to add a line if it's not there, but remove it if it is there
      self.xor_to_set ( v, (f[0], f[1]) )
      self.xor_to_set ( v, (f[1], f[2]) )
      self.xor_to_set ( v, (f[2], f[0]) )

    edges = [ e for e in v ]
    # print ( "Edges = " + str(edges) )
    

    # Copy the 2D points into the 3D top
    for p in points_2d:
      self.points.append ( point ( size_x*p[0], size_y*p[1], size_z*(thickness/2) ) )

    # Copy the 2D points into the 3D bottom
    for p in points_2d:
      self.points.append ( point ( size_x*p[0], size_y*p[1], size_z*(-thickness/2) ) )

    # Copy the 2D top faces to the 3D top faces
    for f in faces_2d:
      self.faces.append ( face ( f[0], f[1], f[2] ) )

    # Copy the 2D top faces to the 3D bottom faces (rearrange for downward normal)
    for f in faces_2d:
      self.faces.append ( face ( np+f[0], np+f[2], np+f[1] ) )
    
    # Make the sides from the edges
    for e in edges:
      self.faces.append ( face ( e[0], np+e[0], e[1] ) )
      self.faces.append ( face ( np+e[0], np+e[1], e[1] ) )
    

class Letter_A (plf_object_flat):

  def __init__  ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):
    size_scale = 0.1 / 6.9
    points_2d = [
      [0.03136,0.4235],[-0.03764,0.4235],[-0.3306,-0.2625],[-0.2306,-0.2625],[-0.1446,-0.06155],
      [0.1454,-0.06155],[0.2364,-0.2625],[0.3364,-0.2625],[-0.004636,0.2735],[0.1054,0.02645], [-0.1066,0.02645] ]

    faces_2d = [ [2,1,0],[2,0,8],[8,0,7],[2,8,10],[9,8,7],[2,10,4],[4,10,9],[4,9,5],[5,9,7],[2,4,3],[6,5,7] ]

    self.build_from_2D ( points_2d, faces_2d, 0.002, size_x*size_scale, size_y*size_scale, size_z )


class Letter_B (plf_object_flat):

  def __init__  ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    points_2d = [ [-0.002893,-0.004942],[0.001132,-0.004913],[0.001663,-0.00483],[0.002132,-0.004698],
                  [0.002542,-0.004524],[0.003194,-0.004069],[0.003637,-0.003512],[0.003889,-0.002899],
                  [0.003969,-0.002273],[0.003895,-0.001631],[0.003678,-0.001059],[0.003327,-0.0005668],
                  [0.002897,-0.0002142],[0.002262,0.0001404],[0.001564,0.0003515],[0.002242,0.0007336],
                  [0.002581,0.001036],[0.002832,0.001388],[0.002997,0.001793],[0.003089,0.002507],
                  [0.003011,0.003134],[0.00277,0.003729],[0.002358,0.004256],[0.001766,0.004677],
                  [0.0009865,0.004957],[0.0005233,0.005032],[-0.002893,0.005058],[-0.001456,0.003768],
                  [0.0001749,0.003755],[0.0008001,0.003656],[0.001231,0.003352],[0.001449,0.003068],
                  [0.001571,0.002738],[0.001608,0.002375],[0.001551,0.001885],[0.001432,0.001491],
                  [0.001086,0.001174],[0.0006763,0.0009532],[0.0003511,0.0008354],[-0.0001629,0.0007877],
                  [-0.001456,0.0007767],[-0.001456,-0.0005136],[0.0006347,-0.0005269],
                  [0.001257,-0.0006287],[0.001749,-0.0008221],[0.002114,-0.001097],[0.002354,-0.001442],
                  [0.002473,-0.001846],[0.002478,-0.002256],[0.002346,-0.002726],[0.00205,-0.00314],
                  [0.001652,-0.003407],[0.001091,-0.003586],[0.0007435,-0.003635],[-0.001456,-0.003652] ]

    faces_2d  = [ [20,21,32],[48,8,47],[41,39,40],[34,35,17],[17,18,34],[19,20,32],[21,22,31],[23,24,29],[33,34,18],[23,29,30],
                  [32,33,19],[23,30,22],[31,32,21],[18,19,33],[22,30,31],[10,11,46],[12,45,11],[49,50,5],[45,46,11],[48,49,7],
                  [46,47,10],[9,10,47],[7,8,48],[5,6,49],[50,4,5],[9,47,8],[6,7,49],[44,45,13],[4,50,51],[43,44,14],[4,51,3],
                  [42,43,14],[51,2,3],[41,42,39],[52,2,51],[45,12,13],[52,1,2],[44,13,14],[52,53,1],[42,14,37],[1,53,54],
                  [14,35,36],[0,1,54],[15,35,14],[0,54,41],[24,25,29],[26,0,41],[17,35,16],[29,25,28],[16,35,15],[28,25,27],
                  [14,36,37],[27,25,26],[42,37,38],[27,26,40],[42,38,39],[40,26,41] ]

    self.build_from_2D ( points_2d, faces_2d, 0.002, size_x, size_y, size_z )



class Letter_C (plf_object_flat):

  def __init__  ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    points_2d = [ [0.003667,0.004266,0],[0.002432,0.004721,0],[0.001341,0.004982,0],[0.0003251,0.005066,0],[-0.000431,0.005021,0],
                  [-0.001146,0.004891,0],[-0.001817,0.00468,0],[-0.002437,0.004393,0],[-0.003002,0.004034,0],[-0.003507,0.003609,0],
                  [-0.003948,0.003122,0],[-0.00432,0.002578,0],[-0.004617,0.001981,0],[-0.004835,0.001337,0],[-0.00497,0.00065,0],
                  [-0.005016,-7.514e-05,0],[-0.004982,-0.0005996,0],[-0.00488,-0.001144,0],[-0.004709,-0.001695,0],[-0.004466,-0.002241,0],
                  [-0.00415,-0.00277,0],[-0.003759,-0.003269,0],[-0.003292,-0.003724,0],[-0.002748,-0.004125,0],[-0.002124,-0.004459,0],
                  [-0.001419,-0.004713,0],[-0.0006319,-0.004874,0],[0.0002394,-0.00493,0],[0.00162,-0.004819,0],[0.002217,-0.004689,0],
                  [0.002766,-0.004518,0],[0.003767,-0.004074,0],[0.003767,-0.002546,0],[0.002641,-0.003148,0],[0.002067,-0.003363,0],
                  [0.0009251,-0.003613,0],[-0.0002016,-0.003614,0],[-0.001236,-0.003374,0],[-0.002111,-0.002918,0],[-0.002802,-0.002267,0],
                  [-0.003287,-0.001446,0],[-0.003541,-0.0004784,0],[-0.003539,0.0005767,0],[-0.00328,0.001539,0],[-0.002789,0.002366,0],
                  [-0.002098,0.003029,0],[-0.001236,0.003499,0],[-0.0002336,0.003748,0],[0.0008678,0.003754,0],[0.001962,0.003536,0],
                  [0.002514,0.00334,0],[0.003667,0.002767,0] ]

    faces_2d  = [ [34,35,28],[35,36,27],[17,18,40],[23,24,38],[29,30,34],[45,46,7],[1,2,49],[18,19,40],[27,28,35],[37,38,24],
                  [43,44,11],[33,34,30],[38,22,23],[45,8,9],[31,33,30],[50,0,1],[5,6,46],[51,0,50],[31,32,33],[46,6,7],
                  [38,39,22],[42,43,13],[49,50,1],[44,45,9],[47,4,5],[25,26,37],[34,28,29],[40,41,17],[14,15,42],[9,10,44],
                  [13,14,42],[11,12,43],[39,20,21],[39,40,20],[7,8,45],[19,20,40],[21,22,39],[17,41,16],[48,49,2],[43,12,13],
                  [3,4,47],[46,47,5],[48,2,3],[15,41,42],[15,16,41],[44,10,11],[27,36,26],[36,37,26],[47,48,3],[25,37,24] ]

    self.build_from_2D ( points_2d, faces_2d, 0.002, size_x, size_y, size_z )


class Letter_D (plf_object_flat):

  def __init__  ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    points_2d = [ [-0.003143,-0.0051],[0.001769,-0.0051],[0.003432,-0.0034],[0.003432,0.0032],[0.001769,0.0047],[-0.003143,0.0047],
                  [-0.001343,-0.0032],[0.0008687,-0.0032],[0.001554,-0.0026],[0.001554,0.0022],[0.0008687,0.0029],[-0.001343,0.0029] ]
    faces_2d  = [ [0,7,6],[0,1,7],[1,8,7],[1,2,8],[2,9,8],[2,3,9],[3,10,9],[3,4,10],[4,11,10],[4,5,11],[5,6,11],[0,6,5] ]
    
    self.build_from_2D ( points_2d, faces_2d, 0.002, size_x, size_y, size_z )


class Letter_E (plf_object_flat):

  def __init__  ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    points_2d = [ [0.002762,0.004985],[-0.002913,0.004985],[-0.002913,-0.005015],[0.002894,-0.005015],[0.002894,-0.003724],
                  [-0.001476,-0.003724],[-0.001476,-0.0006158],[0.001922,-0.0006158],[0.001922,0.0006745],[-0.001476,0.0006745],
                  [-0.001476,0.003695],[0.002762,0.003695] ]

    faces_2d = [ [2,10,1],[10,0,1],[10,11,0],[2,9,10],[2,6,9],[6,8,9],[6,7,8],[2,5,6],[2,4,5],[2,3,4] ]

    self.build_from_2D ( points_2d, faces_2d, 0.002, size_x, size_y, size_z )


class Letter_F (plf_object_flat):

  def __init__  ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    points_2d = [ [0.002762,0.004985],[-0.002913,0.004985],[-0.002913,-0.005015],[-0.001477,-0.005015],[-0.001476,-0.0006158],
                  [0.001922,-0.0006158],[0.001922,0.0006745],[-0.001476,0.0006745],[-0.001476,0.003695],[0.002762,0.003695] ]

    faces_2d = [ [2,4,1],[8,9,0],[5,6,7],[8,0,1],[4,5,7],[7,8,1],[1,4,7],[3,4,2] ]

    self.build_from_2D ( points_2d, faces_2d, 0.002, size_x, size_y, size_z )


class Letter_G (plf_object_flat):

  def __init__  ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    points_2d = [ [0.003752,0],[0.0004801,0],[0.0004801,-0.00131],[0.002352,-0.00131],[0.002352,-0.00331],
                  [0.0009727,-0.003644],[0.0002373,-0.003696],[-0.0008584,-0.003573],[-0.001814,-0.003219],[-0.002602,-0.00266],
                  [-0.003198,-0.00192],[-0.003574,-0.001024],[-0.003706,0],[-0.003574,0.001014],[-0.003201,0.00191],
                  [-0.00262,0.002661],[-0.001862,0.003236],[-0.0009609,0.003603],[0,0.003732],[0.001226,0.003624],
                  [0.002397,0.003303],[0.003552,0.002775],[0.003552,0.00419],[0.002226,0.00469],[0.001148,0.004946],
                  [0,0.005018],[-0.000647,0.004974],[-0.001339,0.004843],[-0.00199,0.004632],[-0.002596,0.004345],
                  [-0.003151,0.003988],[-0.003648,0.003566],[-0.004084,0.003085],[-0.004453,0.002548],[-0.004749,0.001963],
                  [-0.004967,0.001333],[-0.005102,0.0006638],[-0.005148,0],[-0.005103,-0.0007364],[-0.004972,-0.001397],
                  [-0.004758,-0.002017],[-0.004467,-0.00259],[-0.004105,-0.003114],[-0.003675,-0.003582],[-0.003183,-0.003991],
                  [-0.002634,-0.004335],[-0.002033,-0.004611],[-0.001384,-0.004814],[-0.000692,-0.004939],[0,-0.004982],
                  [0.001315,-0.004901],[0.002512,-0.004643],[0.003752,-0.004182] ]

    faces_2d = [ [36,37,12],[20,21,22],[1,2,3],[19,20,23],[0,1,3],[18,19,24],[0,3,52],[17,18,26],[52,3,4],[20,22,23],[52,4,51],
                 [19,23,24],[4,5,51],[16,17,28],[5,50,51],[18,24,25],[5,6,50],[15,16,30],[50,6,49],[18,25,26],[6,48,49],
                 [17,26,27],[6,7,48],[14,15,32],[7,47,48],[17,27,28],[7,46,47],[16,28,29],[7,8,46],[13,14,34],[8,45,46],
                 [16,29,30],[8,44,45],[15,30,31],[8,9,44],[12,13,36],[9,43,44],[15,31,32],[9,42,43],[14,32,33],[9,10,42],
                 [11,12,38],[33,34,14],[35,36,13],[37,38,12],[39,40,11],[41,42,10],[10,40,41],[34,35,13],[38,39,11],[10,11,40] ]

    self.build_from_2D ( points_2d, faces_2d, 0.002, size_x, size_y, size_z )


class Letter_H (plf_object_flat):

  def __init__  ( self, size_x=1.0, size_y=1.0, size_z=1.0 ):

    points_2d = [ [0.004238,0.005],[0.002801,0.005],[0.002801,0.0006452],[-0.002801,0.0006452],[-0.002801,0.005],
                  [-0.004238,0.005],[-0.004238,-0.005],[-0.002801,-0.005],[-0.002801,-0.0006452],[0.002801,-0.0006452],
                  [0.002801,-0.005],[0.004238,-0.005] ]

    faces_2d = [ [6,4,5],[6,3,4],[2,0,1],[2,11,0],[6,8,3],[8,2,3],[8,9,2],[9,11,2],[6,7,8],[10,11,9] ]

    self.build_from_2D ( points_2d, faces_2d, 0.002, size_x, size_y, size_z )






def get_named_shape ( glyph_name, size_x=1.0, size_y=1.0, size_z=1.0 ):

    # print ( "get_named_shape: " + glyph_name )
    shape_plf = None
    if   "Octahedron" == glyph_name:
        shape_plf = CellBlender_Octahedron  ( size_x, size_y, size_z )
    elif "Cube" == glyph_name:
        shape_plf = CellBlender_Cube ( size_x, size_y, size_z )
    elif "Icosahedron" == glyph_name:
        shape_plf = CellBlender_Icosahedron ( size_x, size_y, size_z )
    elif "Cone" == glyph_name:
        shape_plf = CellBlender_Cone ( size_x, size_y, size_z )
    elif "Cylinder" == glyph_name:
        shape_plf = CellBlender_Cylinder ( size_x, size_y, size_z )
    elif "Torus" == glyph_name:
        shape_plf = CellBlender_Torus ( size_x, size_y, size_z )
    elif "Sphere_1" == glyph_name:
        shape_plf = CellBlender_Sphere1 ( size_x, size_y, size_z )
    elif "Sphere_2" == glyph_name:
        shape_plf = CellBlender_Sphere2 ( size_x, size_y, size_z )
    elif "Receptor" == glyph_name:
        shape_plf = CellBlender_Receptor ( size_x, size_y, size_z )
    elif "Cube" == glyph_name:
        shape_plf = BasicBox ( size_x, size_y, size_z )
    elif "Pyramid" == glyph_name:
        shape_plf = Pyramid ( size_x, size_y, size_z )
    elif "Tetrahedron" == glyph_name:
        shape_plf = Tetrahedron ( size_x, size_y, size_z )
    elif "Letter_A" == glyph_name:
        shape_plf = Letter_A ( size_x, size_y, size_z )
    elif "Letter_B" == glyph_name:
        shape_plf = Letter_B ( size_x, size_y, size_z )
    elif "Letter_C" == glyph_name:
        shape_plf = Letter_C ( size_x, size_y, size_z )
    elif "Letter_D" == glyph_name:
        shape_plf = Letter_D ( size_x, size_y, size_z )
    elif "Letter_E" == glyph_name:
        shape_plf = Letter_E ( size_x, size_y, size_z )
    elif "Letter_F" == glyph_name:
        shape_plf = Letter_F ( size_x, size_y, size_z )
    elif "Letter_G" == glyph_name:
        shape_plf = Letter_G ( size_x, size_y, size_z )
    elif "Letter_H" == glyph_name:
        shape_plf = Letter_H ( size_x, size_y, size_z )
    else:
        shape_plf = BasicBox ( size_x, size_y, size_z )

    return shape_plf


#### End of Molecule Shape Code ####











# Molecule Operators:

class MCELL_OT_molecule_add(bpy.types.Operator):
    bl_idname = "mcell.molecule_add"
    bl_label = "Add Molecule"
    bl_description = "Add a new molecule type to an MCell model"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        context.scene.mcell.molecules.add_molecule(context)
        return {'FINISHED'}

class MCELL_OT_molecule_remove(bpy.types.Operator):
    bl_idname = "mcell.molecule_remove"
    bl_label = "Remove Molecule"
    bl_description = "Remove selected molecule type from an MCell model"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        context.scene.mcell.molecules.remove_active_molecule(context)
        self.report({'INFO'}, "Deleted Molecule")
        return {'FINISHED'}


class MCELL_OT_set_molecule_glyph(bpy.types.Operator):
    bl_idname = "mcell.set_molecule_glyph"
    bl_label = "Set Molecule Glyph"
    bl_description = "Set molecule glyph to desired shape in glyph library"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):

        mcell = context.scene.mcell
        mcell.molecule_glyphs.status = ""
        select_objs = context.selected_objects
        if (len(select_objs) != 1):
            mcell.molecule_glyphs.status = "Select One Molecule"
            return {'FINISHED'}
        if (select_objs[0].type != 'MESH'):
            mcell.molecule_glyphs.status = "Selected Object Not a Molecule"
            return {'FINISHED'}

        glyph_name = mcell.molecule_glyphs.glyph

        set_molecule_glyph ( context, glyph_name )

        return {'FINISHED'}



# Callbacks for all Property updates appear to require global (non-member) functions.
# This is circumvented by simply calling the associated member function passed as self:
""" Old Callbacks called corresponding from class ... new version should do this as well """
def check_callback(self, context):
    self.check_callback(context)
    return


def display_callback(self, context):
    self.display_callback(context)
    return



def name_change_callback(self, context):
    print ( "name_change_callback called with self = " + str(self) )
    print ( "  old = " + self.old_name + " => new = " + self.name )
    old_mol_name = "mol_" + self.old_name
    new_mol_name = "mol_" + self.name

    if old_mol_name + '_mat' in bpy.data.materials:
        bpy.data.materials[old_mol_name + '_mat'].name = new_mol_name + '_mat'
    if old_mol_name + '_shape' in bpy.data.meshes:
        bpy.data.meshes[old_mol_name + '_shape'].name = new_mol_name + '_shape'
    if old_mol_name + '_shape' in bpy.data.objects:
        bpy.data.objects[old_mol_name + '_shape'].name = new_mol_name + '_shape'
    if old_mol_name + '_pos' in bpy.data.meshes:
        bpy.data.meshes[old_mol_name + '_pos'].name = new_mol_name + '_pos'
    if old_mol_name in bpy.data.objects:
        bpy.data.objects[old_mol_name].name = new_mol_name

    self.old_name = self.name

    #self.check_callback(context)
    return


#def display_callback(self, context):
#    #self.display_callback(context)
#    return

def glyph_visibility_callback(self, context):
    # print ( "Glyph vis change callback for molecule " + self.name )
    ms = context.scene.mcell
    show_name = "mol_" + self.name
    show_shape_name = show_name + "_shape"
    objs = context.scene.objects
    objs[show_name].hide = not self.glyph_visibility
    objs[show_shape_name].hide = not self.glyph_visibility
    return

def glyph_show_only_callback(self, context):
    # print ( "Glyph show only callback for molecule " + self.name )
    # Note the check before set to keep from infinite recursion in properties!!
    if self.glyph_show_only != False:
        self.glyph_show_only = False
    ms = context.scene.mcell.molecules
    ml = ms.molecule_list
    show_only_name = "mol_" + self.name
    show_only_shape_name = show_only_name + "_shape"
    show_only_items = [show_only_name, show_only_shape_name]
    # print ( "Only showing " + str(show_only_items) )
    
    # Note the check before set to keep from infinite recursion in properties!!
    for o in context.scene.objects:
        if o.name.startswith("mol_"):
            if o.name in show_only_items:
                if o.hide != False:
                    o.hide = False
            else:
                if o.hide != True:
                    o.hide = True
    for o in ml:
        if o.name == self.name:
            if o.glyph_visibility != True:
                o.glyph_visibility = True
        else:
            if o.glyph_visibility != False:
                o.glyph_visibility = False
    if self.name in ms.molecule_list:
        # Select this item in the list as well
        ms.active_mol_index = ms.molecule_list.find ( self.name )
    return

def shape_change_callback(self, context):
    # print ( "Shape change callback for molecule " + self.name )
    self.create_mol_data () # ( context )
    return


import os



class MCellMoleculeProperty(bpy.types.PropertyGroup):
    contains_cellblender_parameters = BoolProperty(name="Contains CellBlender Parameters", default=True)
    name = StringProperty(
        name="Molecule Name", default="Molecule",
        description="The molecule species name",
        update=name_change_callback)
    old_name = StringProperty(name="Old Mol Name", default="Molecule")

    shape_name = StringProperty(name="ShapeName", default="")
    material_name = StringProperty(name="MatName", default="")

    glyph_visibility = BoolProperty ( default=True, description='Show this molecule glyph', update=glyph_visibility_callback )
    glyph_show_only = BoolProperty ( default=False, description='Show only this molecule glyph', update=glyph_show_only_callback )

    id = IntProperty(name="Molecule ID", default=0)
    type_enum = [
        ('2D', "Surface Molecule", ""),
        ('3D', "Volume Molecule", "")]
    type = EnumProperty(
        items=type_enum, name="Molecule Type",
        default='3D',
        description="Surface molecules are constrained to surfaces/meshes. "    
                    "Volume molecules exist in space.")
    diffusion_constant = PointerProperty ( name="Molecule Diffusion Constant", type=parameter_system.Parameter_Reference )
    lr_bar_trigger = BoolProperty("lr_bar_trigger", default=False)
    bnglLabel = StringProperty(
        name="BNGL Label", default="",
        description="The molecule BNGL label",
        update=check_callback)
    target_only = BoolProperty(
        name="Target Only",
        description="If selected, molecule will not initiate reactions when "
                    "it runs into other molecules. Can speed up simulations.")

    custom_time_step =   PointerProperty ( name="Molecule Custom Time Step",   type=parameter_system.Parameter_Reference )
    custom_space_step =  PointerProperty ( name="Molecule Custom Space Step",  type=parameter_system.Parameter_Reference )
    # TODO: Add after data model release:  maximum_step_length =  PointerProperty ( name="Maximum Step Length",  type=parameter_system.Parameter_Reference )

    usecolor = BoolProperty ( name="Use this Color", default=True, description='Use Molecule Color instead of Material Color', update=display_callback )
    color = FloatVectorProperty ( name="", min=0.0, max=1.0, default=(0.5,0.5,0.5), subtype='COLOR', description='Molecule Color', update=display_callback )
    alpha = FloatProperty ( name="Alpha", min=0.0, max=1.0, default=1.0, description="Alpha (inverse of transparency)", update=display_callback )
    emit = FloatProperty ( name="Emit", min=0.0, default=1.0, description="Emits Light (brightness)", update=display_callback )
    scale = FloatProperty ( name="Scale", min=0.0001, default=1.0, description="Relative size (scale) for this molecule", update=shape_change_callback )
    previous_scale = FloatProperty ( name="Previous_Scale", min=0.0, default=1.0, description="Previous Scale" )
    #cumulative_scale = FloatProperty ( name="Cumulative_Scale", min=0.0, default=1.0, description="Cumulative Scale" )

    glyph_lib = os.path.join(os.path.dirname(__file__), "glyph_library.blend", "Mesh", "")
    glyph_enum = [
        ('Cone', "Cone", ""),
        ('Cube', "Cube", ""),
        ('Cylinder', "Cylinder", ""),
        ('Icosahedron', "Icosahedron", ""),
        ('Octahedron', "Octahedron", ""),
        ('Receptor', "Receptor", ""),
        ('Sphere_1', "Sphere_1", ""),
        ('Sphere_2', "Sphere_2", ""),
        ('Torus', "Torus", ""),
        ('Tetrahedron', "Tetrahedron", ""),
        ('Pyramid', "Pyramid", ""),
        ('Letter', "Letter", "")]
    glyph = EnumProperty ( items=glyph_enum, name="Molecule Shape", update=shape_change_callback )

    letter_enum = [
        ('A', "A", ""),
        ('B', "B", ""),
        ('C', "C", ""),
        ('D', "D", ""),
        ('E', "E", ""),
        ('F', "F", ""),
        ('G', "G", ""),
        ('H', "H", "")]
    letter = EnumProperty ( items=letter_enum, name="Molecule Letter", update=shape_change_callback )

    export_viz = bpy.props.BoolProperty(
        default=False, description="If selected, the molecule will be "
                                   "included in the visualization data.")
    status = StringProperty(name="Status")


    name_show_help = BoolProperty ( default=False, description="Toggle more information about this parameter" )
    bngl_label_show_help = BoolProperty ( default=False, description="Toggle more information about this parameter" )
    type_show_help = BoolProperty ( default=False, description="Toggle more information about this parameter" )
    target_only_show_help = BoolProperty ( default=False, description="Toggle more information about this parameter" )


    def init_properties ( self, parameter_system ):
        self.name = "Molecule_"+str(self.id)
        self.old_name = self.name

        helptext = "Molecule Diffusion Constant\n" + \
                   "This molecule diffuses in space with 3D diffusion constant for volume molecules.\n" + \
                   "This molecule diffuses on a surface with 2D diffusion constant for surface molecules.\n" + \
                   "The Diffusion Constant can be zero, in which case the molecule doesnt move."
        self.diffusion_constant.init_ref   ( parameter_system, "Mol_Diff_Const_Type", user_name="Diffusion Constant",   user_expr="0", user_units="cm^2/sec", user_descr=helptext )

        helptext = "Molecule Custom Time Step\n" + \
                   "This molecule should take timesteps of this length (in seconds).\n" + \
                   "Use either this or CUSTOM_SPACE_STEP, not both."
        self.custom_time_step.init_ref     ( parameter_system, "Mol_Time_Step_Type",  user_name="Custom Time Step",     user_expr="",  user_units="seconds",  user_descr=helptext )

        helptext = "Molecule Custom Space Step\n" + \
                   "This molecule should take steps of this average length (in microns).\n" + \
                   "If you use this directive, do not set CUSTOM_TIME_STEP.\n" + \
                   "Providing a CUSTOM_SPACE_STEP for a molecule overrides a potentially\n" + \
                   "present global SPACE_STEP for this particular molecule."
        self.custom_space_step.init_ref    ( parameter_system, "Mol_Space_Step_Type", user_name="Custom Space Step",    user_expr="",  user_units="microns",  user_descr=helptext )
        self.create_mol_data() #(context)
        # TODO: Add after data model release:  self.maximum_step_length.init_ref  ( parameter_system, "Max_Step_Len_Type",   user_name="Maximum Step Length",  user_expr="",  user_units="microns",  user_descr="Molecule should never step farther than this length during a single timestep. Use with caution (see documentation)." )


    def remove_properties ( self, context ):
        print ( "Removing all Molecule Properties ... not implemented yet!" )


    def initialize ( self, context ):
        # This assumes that the ID has already been assigned!!!
        self.name = "Molecule_"+str(self.id)
        self.old_name = self.name
        self.glyph = self.glyph_enum[random.randint(0,len(self.glyph_enum)-1)][0]
        self.create_mol_data() # (context)


    def create_mol_data ( self ):

        meshes = bpy.data.meshes
        mats = bpy.data.materials
        objs = bpy.data.objects
        scn = bpy.context.scene
        scn_objs = scn.objects

        mol_name = "mol_" + self.name
        mol_pos_mesh_name = mol_name + "_pos"
        shape_name = mol_name + "_shape"
        material_name = mol_name + "_mat"


        # First be sure that the parent "empty" for holding molecules is available (create as needed)
        mols_obj = bpy.data.objects.get("molecules")
        if not mols_obj:
            bpy.ops.object.add(location=[0, 0, 0])
            mols_obj = bpy.context.selected_objects[0]
            mols_obj.name = "molecules"
            mols_obj.location.x = 0
            mols_obj.location.y = 0
            mols_obj.location.z = 0
            mols_obj.lock_location[0] = True
            mols_obj.lock_location[1] = True
            mols_obj.lock_location[2] = True
            mols_obj.lock_rotation[0] = True
            mols_obj.lock_rotation[1] = True
            mols_obj.lock_rotation[2] = True
            mols_obj.lock_scale[0] = True
            mols_obj.lock_scale[1] = True
            mols_obj.lock_scale[2] = True
            mols_obj.select = False
            mols_obj.hide_select = True
            mols_obj.hide = True

        # Build the new shape vertices and faces
        # print ( "Creating a new glyph for " + self.name )

        size = 1.0 * self.scale
        glyph_name = self.glyph
        if glyph_name == "Letter":
            glyph_name = "Letter_" + self.letter
        shape_plf = get_named_shape ( glyph_name, size_x=size, size_y=size, size_z=size )

        shape_vertices = []
        for point in shape_plf.points:
            shape_vertices.append ( mathutils.Vector((point.x,point.y,point.z)) )
        shape_faces = []
        for face_element in shape_plf.faces:
            shape_faces.append ( face_element.verts )


        # Delete the old object and mesh
        if shape_name in objs:
            scn_objs.unlink ( objs[shape_name] )
            objs.remove ( objs[shape_name] )
        if shape_name in meshes:
            meshes.remove ( meshes[shape_name] )

        # Create and build the new mesh
        mol_shape_mesh = bpy.data.meshes.new ( shape_name )
        mol_shape_mesh.from_pydata ( shape_vertices, [], shape_faces )
        mol_shape_mesh.update()

        # Create the new shape object from the mesh
        mol_shape_obj = bpy.data.objects.new ( shape_name, mol_shape_mesh )
        # Be sure the new shape is at the origin, and lock it there.
        mol_shape_obj.location.x = 0
        mol_shape_obj.location.y = 0
        mol_shape_obj.location.z = 0
        mol_shape_obj.lock_location[0] = True
        mol_shape_obj.lock_location[1] = True
        mol_shape_obj.lock_location[2] = True
        mol_shape_obj.track_axis = "POS_Z"
        # Allow the shape to be selected so it can have its size changed like any other object.
        mol_shape_obj.hide_select = False

        # Add the shape to the scene as a glyph for the object
        scn.objects.link ( mol_shape_obj )

        # Look-up material, create if needed.
        # Associate material with mesh shape.
        # Bob: Maybe we need to associate it with the OBJECT with: shape_object.material_slots[0].link = 'OBJECT'
        mol_mat = mats.get(material_name)
        if not mol_mat:
            mol_mat = mats.new(material_name)
            # Need to pick a color here ?
        if not mol_shape_mesh.materials.get(material_name):
            mol_shape_mesh.materials.append(mol_mat)

        # Create a "mesh" to hold instances of molecule positions
        mol_pos_mesh = meshes.get(mol_pos_mesh_name)
        if not mol_pos_mesh:
            mol_pos_mesh = meshes.new(mol_pos_mesh_name)

        # Create object to contain the mol_pos_mesh data
        mol_obj = objs.get(mol_name)
        if not mol_obj:
            mol_obj = objs.new(mol_name, mol_pos_mesh)
            scn_objs.link(mol_obj)
            mol_shape_obj.parent = mol_obj
            mol_obj.dupli_type = 'VERTS'
            mol_obj.use_dupli_vertices_rotation = True
            mol_obj.parent = mols_obj

        # Be sure the new object is at the origin, and lock it there.
        mol_obj.location.x = 0
        mol_obj.location.y = 0
        mol_obj.location.z = 0
        mol_obj.lock_location[0] = True
        mol_obj.lock_location[1] = True
        mol_obj.lock_location[2] = True
        # Also lock the rotation and scaling for the molecule positions.
        mol_obj.lock_rotation[0] = True
        mol_obj.lock_rotation[1] = True
        mol_obj.lock_rotation[2] = True
        mol_obj.lock_scale[0] = True
        mol_obj.lock_scale[1] = True
        mol_obj.lock_scale[2] = True

        # Allow the molecule locations to be selected ... this may either help or become annoying.
        mol_obj.hide_select = False

        # Add the shape to the scene as a glyph for the object
        mol_obj.dupli_type = 'VERTS'
        mol_shape_obj.parent = mol_obj



    def remove_mol_data ( self, context ):

        meshes = bpy.data.meshes
        mats = bpy.data.materials
        objs = bpy.data.objects
        scn = bpy.context.scene
        scn_objs = scn.objects

        mol_obj_name        = "mol_" + self.name
        mol_shape_obj_name  = mol_obj_name + "_shape"
        mol_shape_mesh_name = mol_obj_name + "_shape"
        mol_pos_mesh_name   = mol_obj_name + "_pos"
        mol_material_name   = mol_obj_name + "_mat"

        mols_obj = objs.get("molecules")

        mol_obj = objs.get(mol_obj_name)
        mol_shape_obj = objs.get(mol_shape_obj_name)
        mol_shape_mesh = meshes.get(mol_shape_mesh_name)
        mol_pos_mesh = meshes.get(mol_pos_mesh_name)
        mol_material = mats.get(mol_material_name)

        if mol_obj:
            scn_objs.unlink ( mol_obj )
        if mol_shape_obj:
            scn_objs.unlink ( mol_shape_obj )

        if mol_obj.users <= 0:
            objs.remove ( mol_obj )
            meshes.remove ( mol_pos_mesh )

        if mol_shape_obj.users <= 0:
            objs.remove ( mol_shape_obj )
            meshes.remove ( mol_shape_mesh )

        if mol_material.users <= 0:
            mats.remove ( mol_material )



    def build_data_model_from_properties ( self ):
        m = self

        m_dict = {}
        m_dict['data_model_version'] = "DM_2015_07_24_1330"
        m_dict['mol_name'] = m.name
        m_dict['mol_bngl_label'] = m.bnglLabel
        m_dict['mol_type'] = str(m.type)
        m_dict['diffusion_constant'] = m.diffusion_constant.get_expr()
        m_dict['target_only'] = m.target_only
        m_dict['custom_time_step'] = m.custom_time_step.get_expr()
        m_dict['custom_space_step'] = m.custom_space_step.get_expr()
        m_dict['custom_space_step'] = m.custom_space_step.get_expr()
        # TODO: Add after data model release:   m_dict['maximum_step_length'] = m.maximum_step_length.get_expr()
        m_dict['maximum_step_length'] = ""  # TODO: Remove this line after data model release
        m_dict['export_viz'] = m.export_viz

        return m_dict


    @staticmethod
    def upgrade_data_model ( dm ):
        # Upgrade the data model as needed. Return updated data model or None if it can't be upgraded.
        print ( "------------------------->>> Upgrading MCellMoleculeProperty Data Model" )
        if not ('data_model_version' in dm):
            # Make changes to move from unversioned to DM_2014_10_24_1638
            dm['data_model_version'] = "DM_2014_10_24_1638"

        if dm['data_model_version'] == "DM_2014_10_24_1638":
            # Change on June 2nd, 2015: the mol_bngl_label field was added, but data model update wasn't done until July 24th, 2015
            dm['mol_bngl_label'] = ""
            dm['data_model_version'] = "DM_2015_07_24_1330"

        # Check that the upgraded data model version matches the version for this property group
        if dm['data_model_version'] != "DM_2015_07_24_1330":
            data_model.flag_incompatible_data_model ( "Error: Unable to upgrade MCellMoleculeProperty data model to current version." )
            return None

        return dm



    def build_properties_from_data_model ( self, context, dm_dict ):
        # Check that the data model version matches the version for this property group
        if dm_dict['data_model_version'] != "DM_2015_07_24_1330":
            data_model.handle_incompatible_data_model ( "Error: Unable to upgrade MCellMoleculeProperty data model to current version." )
        # Now convert the updated Data Model into CellBlender Properties
        self.name = dm_dict["mol_name"]
        if "mol_bngl_label" in dm_dict: self.bnglLabel = dm_dict['mol_bngl_label']
        if "mol_type" in dm_dict: self.type = dm_dict["mol_type"]
        if "diffusion_constant" in dm_dict: self.diffusion_constant.set_expr ( dm_dict["diffusion_constant"] )
        if "target_only" in dm_dict: self.target_only = dm_dict["target_only"]
        if "custom_time_step" in dm_dict: self.custom_time_step.set_expr ( dm_dict["custom_time_step"] )
        if "custom_space_step" in dm_dict: self.custom_space_step.set_expr ( dm_dict["custom_space_step"] )
        # TODO: Add after data model release:   self.maximum_step_length.set_expr ( dm_dict["maximum_step_length"] )
        if "export_viz" in dm_dict: self.export_viz = dm_dict["export_viz"]

    def check_properties_after_building ( self, context ):
        print ( "check_properties_after_building not implemented for " + str(self) )

    # Exporting to an MDL file could be done just like this
    def print_details( self ):
        print ( "Name = " + self.name )

    def draw_props ( self, layout, molecules, parameter_system ):

        helptext = "Molecule Name\nThis is the name used in Reactions and Display"
        parameter_system.draw_prop_with_help ( layout, "Name", self, "name", "name_show_help", self.name_show_help, helptext )

        helptext = "This is a BNGL label that is used to identify a given species \n \
                    as a complex molecule."
        parameter_system.draw_prop_with_help ( layout, "BNGL Label", self, "bnglLabel", "bngl_label_show_help", self.bngl_label_show_help, helptext )

        helptext = "Molecule Type: Either Volume or Surface\n" + \
                   "Volume molecules are placed in and diffuse in 3D spaces." + \
                   "Surface molecules are placed on and diffuse on 2D surfaces."
        parameter_system.draw_prop_with_help ( layout, "Molecule Type", self, "type", "type_show_help", self.type_show_help, helptext )

        self.diffusion_constant.draw(layout,parameter_system)
        #self.lr_bar_trigger = False
        
        lr_bar_display = 0
        if len(self.custom_space_step.get_expr().strip()) > 0:
            # Set lr_bar_display directly
            lr_bar_display = self.custom_space_step.get_value()
        else:
            # Calculate lr_bar_display from diffusion constant and time step
            dc = 1e8 * self.diffusion_constant.get_value() # convert from cm2/s to um2/s 
            ts = bpy.context.scene.mcell.initialization.time_step.get_value()
            if len(self.custom_time_step.get_expr().strip()) > 0:
                ts = self.custom_time_step.get_value()
            lr_bar_display = 2 * math.sqrt ( 4 * dc * ts / math.pi )

        row = layout.row()
        row.label(text="lr_bar:  %.4g  microns"%(lr_bar_display), icon='BLANK1')  # BLANK1 RIGHTARROW_THIN SMALL_TRI_RIGHT_VEC DISCLOSURE_TRI_RIGHT_VEC DRIVER DOT FORWARD LINKED
        #layout.prop ( self, "lr_bar_trigger", icon='NONE', text="lr_bar: " + str(lr_bar_display) )

        box = layout.box()
        row = box.row(align=True)
        row.alignment = 'LEFT'
        if not molecules.show_display:
            row.prop(molecules, "show_display", icon='TRIA_RIGHT', text="Display Options", emboss=False)
        else:
            row.prop(molecules, "show_display", icon='TRIA_DOWN',  text="Display Options", emboss=False)

            row = box.row()
            row.prop(self, "glyph", text="Shape")

            if self.glyph == "Letter":
                row = box.row()
                row.prop(self, "letter", text="Letter")

            mat_name = "mol_" + self.name+"_mat"
            if mat_name in bpy.data.materials:
                row = box.row()
                row.prop ( bpy.data.materials[mat_name], "diffuse_color", text="Color" )
                row = box.row()
                col = row.column()
                col.label ( "Brightness" )
                col = row.column()
                col.prop ( bpy.data.materials[mat_name], "emit", text="Emit" )
                row = box.row()
                col = row.column()
                col.label ( "Scale" )
                col = row.column()
                col.prop ( self, "scale", text="Factor" )
                if len(bpy.data.materials) and (bpy.context.scene.render.engine in {'BLENDER_RENDER', 'BLENDER_GAME'}):
                  if 'mcell' in bpy.context.scene.keys():
                    #print ( "Context OK, showing materials" )
                    mcell = bpy.context.scene.mcell
                    m = molecules.molecule_list[molecules.active_mol_index]
                    mat_name = "mol_" + m.name + "_mat"
                    #print ( "" + mat_name + " in bpy.data.materials = " + str(mat_name in bpy.data.materials) )
                    if mat_name in bpy.data.materials:
                      row = box.row()
                      row.alignment = 'LEFT'
                      if molecules.show_preview:
                        row.prop(molecules, "show_preview", icon='TRIA_DOWN', emboss=False, text="Material Preview (resize to refresh)")
                        box.template_preview(bpy.data.materials[mat_name])
                      else:
                        row.prop(molecules, "show_preview", icon='TRIA_RIGHT', emboss=False)
                  else:
                    print ( "mcell not found, not showing color preview" )
                    pass
            else:
                print ( "Material " + mat_name + " not found, not showing materials" )

            """
            row = box.row()
            row.label ( "Molecule Display Settings" )
            row = box.row()
            col = row.column()
            col.prop ( self, "glyph" )
            col = row.column()
            col.prop ( self, "scale" )
            row = box.row()
            col = row.column()
            mol_mat_name = 'mol_' + self.name + '_mat'
            if False and mol_mat_name in bpy.data.materials.keys():
                # This would control the actual Blender material property directly
                col.prop ( bpy.data.materials[mol_mat_name], "diffuse_color" )
                col = row.column()
                col.prop ( bpy.data.materials[mol_mat_name], "emit" )
            else:
                # This controls the molecule property which changes the Blender property via callback
                # But changing the color via the Materials interface doesn't change these values
                col.prop ( self, "color" )
                col = row.column()
                col.prop ( self, "emit" )
            #col = row.column()
            #col.prop ( self, "usecolor" )
            """

        box = layout.box()
        row = box.row(align=True)
        row.alignment = 'LEFT'
        if not molecules.show_advanced:
            row.prop(molecules, "show_advanced", icon='TRIA_RIGHT',
                     text="Advanced Options", emboss=False)
        else:
            row.prop(molecules, "show_advanced", icon='TRIA_DOWN',
                     text="Advanced Options", emboss=False)
            # row = box.row()
            # row.prop(self, "target_only")
            parameter_system.draw_prop_with_help ( box, "Target Only", self, "target_only", "target_only_show_help", self.target_only_show_help, 
                "Target Only - This molecule will not initiate reactions when\n" +
                "it runs into other molecules. This setting can speed up simulations\n" +
                "when applied to a molecule at high concentrations that reacts with\n" +
                "a molecule at low concentrations (it is more efficient for the\n" +
                "low-concentration molecule to trigger the reactions). This directive\n" +
                "does not affect unimolecular reactions." )
            self.custom_time_step.draw(box,parameter_system)
            self.custom_space_step.draw(box,parameter_system)


    def check_callback(self, context):
        """Allow the parent molecule list (MCellMoleculesListProperty) to do the checking"""
        cellblender_utils.get_parent(self).check(context)
        return


    def display_callback(self, context):
        """One of the display items has changed for this molecule"""
        print ( "Display for molecule \"" + self.name + "\" changed to: " + str(self.glyph) + ", color=" + str(self.color) + ", emit=" + str(self.emit) + ", scale=" + str(self.scale) )
        mol_name = 'mol_' + self.name
        mol_shape_name = mol_name + '_shape'
        if mol_shape_name in bpy.data.objects:
            if self.scale != self.previous_scale:
                # Scale by the ratio of current scale to previous scale
                bpy.data.objects[mol_shape_name].scale *= (self.scale / self.previous_scale)
                self.previous_scale = self.scale
                
            

        mol_mat_name = 'mol_' + self.name + '_mat'
        if mol_mat_name in bpy.data.materials.keys():
            if bpy.data.materials[mol_mat_name].diffuse_color != self.color:
                bpy.data.materials[mol_mat_name].diffuse_color = self.color
            if bpy.data.materials[mol_mat_name].emit != self.emit:
                bpy.data.materials[mol_mat_name].emit = self.emit


        # Refresh the scene
        self.set_mol_glyph ( context )
        cellblender_mol_viz.mol_viz_update(self,context)  # It's not clear why mol_viz_update needs a self. It's not in a class, and doesn't use the "self".
        context.scene.update()  # It's also not clear if this is needed ... but it doesn't seem to hurt!!
        return



    def set_mol_glyph (self, context):
        # Use exact code from MCELL_OT_set_molecule_glyph(bpy.types.Operator).execute
        # Except added a test to see if the molecule exists first!!
        
        mol_name = 'mol_' + self.name
        if mol_name in bpy.data.objects:

            # First set up the selected and active molecules

            mol_obj = bpy.data.objects['mol_' + self.name]     # Is this used before being resest below?
            mol_shape_name = 'mol_' + self.name + '_shape'

            bpy.ops.object.select_all(action='DESELECT')
            context.scene.objects[mol_shape_name].hide_select = False
            context.scene.objects[mol_shape_name].select = True
            context.scene.objects.active = bpy.data.objects[mol_shape_name]


            # Exact code starts here (allow it to duplicate some previous code for now):

            set_molecule_glyph ( context, self.glyph )

        return




    def testing_set_mol_glyph (self, context):

        ###########################################
        ###########################################
        # return
        ###########################################
        ###########################################
        
        mcell = context.scene.mcell
        meshes = bpy.data.meshes
        mcell.molecule_glyphs.status = ""
        #select_objs = context.selected_objects
        #if len(select_objs) == -123:
        #    if (len(select_objs) != 1):
        #        mcell.molecule_glyphs.status = "Select One Molecule"
        #        return {'FINISHED'}
        #    if (select_objs[0].type != 'MESH'):
        #        mcell.molecule_glyphs.status = "Selected Object Not a Molecule"
        #        return {'FINISHED'}

        #mol_obj = select_objs[0]
        #mol_shape_name = mol_obj.name

        # Try to deselect everything
        bpy.ops.object.select_all(action='DESELECT')

        mol_obj = bpy.data.objects['mol_' + self.name]
        mol_shape_name = 'mol_' + self.name + '_shape'
        print ( "Try to select " + mol_shape_name + " from bpy.data.objects["+self.name+"]" )
        context.scene.objects.active = bpy.data.objects[mol_shape_name]

        glyph_name = str(self.glyph)

        # There may be objects in the scene with the same name as the glyphs in
        # the glyph library, so we need to deal with this possibility
        new_glyph_name = glyph_name
        if glyph_name in meshes:
            # pattern: glyph name, period, numbers. (example match: "Cube.001")
            pattern = re.compile(r'%s(\.\d+)' % glyph_name)
            competing_names = [m.name for m in meshes if pattern.match(m.name)]
            # example: given this: ["Cube.001", "Cube.3"], make this: [1, 3]
            trailing_nums = [int(n.split('.')[1]) for n in competing_names]
            # remove dups & sort... better way than list->set->list?
            trailing_nums = list(set(trailing_nums))
            trailing_nums.sort()
            i = 0
            gap = False
            for i in range(0, len(trailing_nums)):
                if trailing_nums[i] != i+1:
                    gap = True
                    break
            if not gap and trailing_nums:
                i+=1
            new_glyph_name = "%s.%03d" % (glyph_name, i + 1)

        print ( "New Glyph Name = " + new_glyph_name )

        if (bpy.app.version[0] > 2) or ( (bpy.app.version[0]==2) and (bpy.app.version[1] > 71) ):
          bpy.ops.wm.link(
              directory=mcell.molecule_glyphs.glyph_lib,
              files=[{"name": glyph_name}], link=False, autoselect=False)
        else:
          bpy.ops.wm.link_append(
              directory=mcell.molecule_glyphs.glyph_lib,
              files=[{"name": glyph_name}], link=False, autoselect=False)

        mol_mat = None
        if len(mol_obj.material_slots) > 0:
          mol_mat = mol_obj.material_slots[0].material

        new_mol_mesh = meshes[new_glyph_name]
        mol_obj.data = new_mol_mesh
        ### causes a problem?  meshes.remove(meshes[mol_shape_name])

        new_mol_mesh.name = mol_shape_name
        if mol_mat != None:
            new_mol_mesh.materials.append(mol_mat)
        print ( "Done setting molecule glyph" )






#class MCell_UL_check_molecule(bpy.types.UIList):
#    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
#        if item.status:
#            layout.label(item.status, icon='ERROR')
#        else:
#            layout.label(item.name, icon='FILE_TICK')


class MCell_UL_check_molecule(bpy.types.UIList):
    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
        # print ("Draw with " + str(data) + " " + str(item) + " " + str(active_data) + " " + str(active_propname) + " " + str(index) )
        if item.status:
            layout.label(item.status, icon='ERROR')
        else:
            col = layout.column()
            col.label(item.name, icon='FILE_TICK')

            ms = context.scene.mcell.molecules
            show_name = "mol_" + item.name
            show_shape_name = show_name + "_shape"
            objs = context.scene.objects
            #col = layout.column()
            #col.operator("mcell.molecule_show_only", icon='VIEWZOOM', text="")
            col = layout.column()
            col.prop(item, "glyph_show_only", text="", icon='VIEWZOOM')
            col = layout.column()
            if item.glyph_visibility:
                col.prop(item, "glyph_visibility", text="", icon='RESTRICT_VIEW_OFF')
            else:
                col.prop(item, "glyph_visibility", text="", icon='RESTRICT_VIEW_ON')
            #col = layout.column()
            #col.prop(objs[show_name], "hide", text="", icon='RESTRICT_VIEW_OFF')
            if ms.show_extra_columns:
                col = layout.column()
                if objs[show_name].hide:
                    # NOTE: For some reason, when Blender displays a boolean, it will use an offset of 1 for true.
                    #       So since GROUP_BONE is the icon BEFORE GROUP_VERTEX, picking it when true shows GROUP_VERTEX.
                    col.prop(objs[show_name], "hide", text="", icon='GROUP_BONE')
                else:
                    col.prop(objs[show_name], "hide", text="", icon='GROUP_VERTEX')
                col = layout.column()
                if objs[show_shape_name].hide:
                    # NOTE: For some reason, when Blender displays a boolean, it will use an offset of 1 for true.
                    #       So since GROUP_BONE is the icon BEFORE GROUP_VERTEX, picking it when true shows GROUP_VERTEX.
                    col.prop(objs[show_shape_name], "hide", text="", icon='FORCE_CHARGE')
                else:
                    col.prop(objs[show_shape_name], "hide", text="", icon='FORCE_LENNARDJONES')


class MCell_OT_molecule_show_all(bpy.types.Operator):
    bl_idname = "mcell.molecule_show_all"
    bl_label = "Show All"
    bl_description = "Show all of the molecules"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        ms = context.scene.mcell.molecules
        print ( "Showing All" )
        for o in ms.molecule_list:
            if not o.glyph_visibility:
                o.glyph_visibility = True
            if o.glyph_show_only:
                o.glyph_show_only = False
        for o in context.scene.objects:
            if o.name.startswith("mol_"):
                o.hide = False
        return {'FINISHED'}


class MCell_OT_molecule_hide_all(bpy.types.Operator):
    bl_idname = "mcell.molecule_hide_all"
    bl_label = "Hide All"
    bl_description = "Hide all of the molecules"
    bl_options = {'REGISTER', 'UNDO'}

    def execute(self, context):
        ms = context.scene.mcell.molecules
        print ( "Hiding All" )
        for o in ms.molecule_list:
            if o.glyph_visibility:
                o.glyph_visibility = False
            if o.glyph_show_only:
                o.glyph_show_only = False
        for o in context.scene.objects:
            if o.name.startswith("mol_"):
                o.hide = True
        return {'FINISHED'}




class MCELL_PT_define_molecules(bpy.types.Panel):
    bl_label = "CellBlender - Define Molecules"
    bl_space_type = "PROPERTIES"
    bl_region_type = "WINDOW"
    bl_context = "scene"
    bl_options = {'DEFAULT_CLOSED'}

    def draw ( self, context ):
        # Call the draw function for the instance being drawn in this panel
        context.scene.mcell.molecules.draw_panel ( context, self )


class MCellMoleculesListProperty(bpy.types.PropertyGroup):
    contains_cellblender_parameters = BoolProperty(name="Contains CellBlender Parameters", default=True)
    molecule_list = CollectionProperty(type=MCellMoleculeProperty, name="Molecule List")
    active_mol_index = IntProperty(name="Active Molecule Index", default=0)
    next_id = IntProperty(name="Counter for Unique Molecule IDs", default=1)  # Start ID's at 1 to confirm initialization
    show_advanced = bpy.props.BoolProperty(default=False)  # If Some Properties are not shown, they may not exist!!!
    show_display = bpy.props.BoolProperty(default=False)  # If Some Properties are not shown, they may not exist!!!
    show_preview = bpy.props.BoolProperty(default=False, name="Material Preview")
    show_extra_columns = bpy.props.BoolProperty(default=False, description="Show additional visibility control columns")

    def init_properties ( self, parameter_system ):
        if self.molecule_list:
            for mol in self.molecule_list:
                mol.init_properties(parameter_system)

    def remove_properties ( self, context ):
        print ( "Removing all Molecule List Properties..." )
        for item in self.molecule_list:
            item.remove_properties(context)
        self.molecule_list.clear()
        self.active_mol_index = 0
        self.next_id = 1
        print ( "Done removing all Molecule List Properties." )
        
    
    def add_molecule ( self, context ):
        """ Add a new molecule to the list of molecules and set as the active molecule """
        new_mol = self.molecule_list.add()
        new_mol.id = self.allocate_available_id()
        new_mol.init_properties(context.scene.mcell.parameter_system)
        new_mol.initialize(context)
        self.active_mol_index = len(self.molecule_list)-1

    def remove_active_molecule ( self, context ):
        """ Remove the active molecule from the list of molecules """
        if len(self.molecule_list) > 0:
            mol = self.molecule_list[self.active_mol_index]
            if mol:
                mol.remove_mol_data(context)
            self.molecule_list.remove ( self.active_mol_index )
            self.active_mol_index -= 1
            if self.active_mol_index < 0:
                self.active_mol_index = 0
            if len(self.molecule_list) <= 0:
                self.next_id = 1
            if self.molecule_list:
                self.check(context)

    def build_data_model_from_properties ( self, context ):
        print ( "Molecule List building Data Model" )
        mol_dm = {}
        mol_dm['data_model_version'] = "DM_2014_10_24_1638"
        mol_list = []
        for m in self.molecule_list:
            mol_list.append ( m.build_data_model_from_properties() )
        mol_dm['molecule_list'] = mol_list
        return mol_dm

    @staticmethod
    def upgrade_data_model ( dm ):
        # Upgrade the data model as needed. Return updated data model or None if it can't be upgraded.
        print ( "------------------------->>> Upgrading MCellMoleculesListProperty Data Model" )
        if not ('data_model_version' in dm):
            # Make changes to move from unversioned to DM_2014_10_24_1638
            dm['data_model_version'] = "DM_2014_10_24_1638"

        if dm['data_model_version'] != "DM_2014_10_24_1638":
            data_model.flag_incompatible_data_model ( "Error: Unable to upgrade MCellMoleculesListProperty data model to current version." )
            return None

        if "molecule_list" in dm:
            for item in dm["molecule_list"]:
                if MCellMoleculeProperty.upgrade_data_model ( item ) == None:
                    return None
        return dm


    def build_properties_from_data_model ( self, context, dm ):
        # Check that the data model version matches the version for this property group
        if dm['data_model_version'] != "DM_2014_10_24_1638":
            data_model.handle_incompatible_data_model ( "Error: Unable to upgrade MCellMoleculesListProperty data model to current version." )

        # Now convert the Data Model into CellBlender Properties

        # Start by removing all molecules from the list
        while len(self.molecule_list) > 0:
            self.remove_active_molecule ( context )

        # Add molecules from the data model
        if "molecule_list" in dm:
            for m in dm["molecule_list"]:
                self.add_molecule(context)
                self.molecule_list[self.active_mol_index].build_properties_from_data_model(context,m)

    def check_properties_after_building ( self, context ):
        print ( "check_properties_after_building not implemented for " + str(self) )


    def check ( self, context ):
        """Checks for duplicate or illegal molecule name"""
        # Note: Some of the list-oriented functionality is appropriate here (since this
        #        is a list), but some of the molecule-specific checks (like name legality)
        #        could be handled by the the molecules themselves. They're left here for now.

        mol = self.molecule_list[self.active_mol_index]

        status = ""

        # Check for duplicate molecule name
        mol_keys = self.molecule_list.keys()
        if mol_keys.count(mol.name) > 1:
            status = "Duplicate molecule: %s" % (mol.name)

        # Check for illegal names (Starts with a letter. No special characters.)
        mol_filter = r"(^[A-Za-z]+[0-9A-Za-z_.]*$)"
        m = re.match(mol_filter, mol.name)
        if m is None:
            status = "Molecule name error: %s" % (mol.name)

        mol.status = status

        return


    def allocate_available_id ( self ):
        """ Return a unique molecule ID for a new molecule """
        if len(self.molecule_list) <= 0:
            # Reset the ID to 1 when there are no more molecules
            self.next_id = 1
        self.next_id += 1
        return ( self.next_id - 1 )


    def draw_layout ( self, context, layout ):
        """ Draw the molecule "panel" within the layout """
        mcell = context.scene.mcell
        if not mcell.initialized:
            mcell.draw_uninitialized ( layout )
        else:
            row = layout.row()
            col = row.column()
            col.template_list("MCell_UL_check_molecule", "define_molecules",
                              self, "molecule_list",
                              self, "active_mol_index",
                              rows=4)
            col = row.column(align=False)
            # Use subcolumns to group logically related buttons together
            subcol = col.column(align=True)
            subcol.operator("mcell.molecule_add", icon='ZOOMIN', text="")
            subcol.operator("mcell.molecule_remove", icon='ZOOMOUT', text="")
            subcol = col.column(align=True)
            subcol.operator("mcell.molecule_show_all", icon='RESTRICT_VIEW_OFF', text="")
            subcol.operator("mcell.molecule_hide_all", icon='RESTRICT_VIEW_ON', text="")
            subcol = col.column(align=True)
            subcol.prop (self, "show_extra_columns", icon='SCRIPTWIN', text="")

            if self.molecule_list:
                mol = self.molecule_list[self.active_mol_index]
                #mol.draw_layout ( context, layout, self )
                mol.draw_props ( layout, self, mcell.parameter_system )


            """ Old Code
            row = layout.row()
            col = row.column()
            col.template_list("MCell_UL_check_molecule", "define_molecules",
                              self, "molecule_list",
                              self, "active_mol_index",
                              rows=2)
            col = row.column(align=True)
            col.operator("mcell.molecule_add", icon='ZOOMIN', text="")
            col.operator("mcell.molecule_remove", icon='ZOOMOUT', text="")
            if self.molecule_list:
                mol = self.molecule_list[self.active_mol_index]
                # The self is needed to pass the "advanced" flag to the molecule
                mol.draw_props ( layout, self, mcell.parameter_system )
            """


    def draw_panel ( self, context, panel ):
        """ Create a layout from the panel and draw into it """
        layout = panel.layout
        self.draw_layout ( context, layout )

